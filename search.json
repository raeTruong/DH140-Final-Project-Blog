[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "title",
    "section": "",
    "text": "PandasDatasaurus\n\n\n\n\n\nJupyter Notebook on how to use the Pandas module\n\n\n\n\n\nAug 2, 2024\n\n\nRachel Truong\n\n\n\n\n\n\n\n\n\n\n\n\nPokéMetrics: Analyzing Stats and Type Effectiveness\n\n\n\n\n\nA blog post on analyzing stats and types for the best Pokémon to have while solo\n\n\n\n\n\nAug 2, 2024\n\n\nRachel Truong\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/Session03_NB2_PandasDatasaurus.html",
    "href": "posts/Session03_NB2_PandasDatasaurus.html",
    "title": "PandasDatasaurus",
    "section": "",
    "text": "https://pandas.pydata.org/\nPandas data-manipulation capabilities are built on top of NumPy, utilizing its fast array processing, and its graphing capabilities are built on top of Matplotlib.\nImport the library:\nimport pandas as pd\nImport the data:\ndinodata = pd.read_csv('https://raw.githubusercontent.com/benjum/UCLA-24A6-DH140/main/data/DatasaurusDozen.csv')\nLook at some data values:\ndinodata\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.384600\n97.179500\n\n\n1\ndino\n51.538500\n96.025600\n\n\n2\ndino\n46.153800\n94.487200\n\n\n3\ndino\n42.820500\n91.410300\n\n\n4\ndino\n40.769200\n88.333300\n\n\n...\n...\n...\n...\n\n\n1841\nwide_lines\n33.674442\n26.090490\n\n\n1842\nwide_lines\n75.627255\n37.128752\n\n\n1843\nwide_lines\n40.610125\n89.136240\n\n\n1844\nwide_lines\n39.114366\n96.481751\n\n\n1845\nwide_lines\n34.583829\n89.588902\n\n\n\n\n1846 rows × 3 columns\nMaking a scatter plot of the data in the x and y columns is easy:\ndinodata.plot(x = 'x', y = 'y', kind = 'scatter')"
  },
  {
    "objectID": "posts/Session03_NB2_PandasDatasaurus.html#basic-data-structures-in-pandas",
    "href": "posts/Session03_NB2_PandasDatasaurus.html#basic-data-structures-in-pandas",
    "title": "PandasDatasaurus",
    "section": "Basic data structures in Pandas",
    "text": "Basic data structures in Pandas\nPython can store values in a variety of data structures: single variables, lists, dictionaries, sets, etc.\nPandas has two key data structures for storing Python variables:\n\nSeries\n\n1D\nLike an array\nItems are labeled by an index\n\nDataframes\n\n2D\nLike a spreadsheet\nItems are labeled by an index (row label) and column name\n\n\ndinodata is a dataframe:\n\ndinodata\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.384600\n97.179500\n\n\n1\ndino\n51.538500\n96.025600\n\n\n2\ndino\n46.153800\n94.487200\n\n\n3\ndino\n42.820500\n91.410300\n\n\n4\ndino\n40.769200\n88.333300\n\n\n...\n...\n...\n...\n\n\n1841\nwide_lines\n33.674442\n26.090490\n\n\n1842\nwide_lines\n75.627255\n37.128752\n\n\n1843\nwide_lines\n40.610125\n89.136240\n\n\n1844\nwide_lines\n39.114366\n96.481751\n\n\n1845\nwide_lines\n34.583829\n89.588902\n\n\n\n\n1846 rows × 3 columns\n\n\n\n\nhead(n): show us the first n rows (5 by default)\ntail(n): show us the last n rows (5 by default)\ninfo() : a range of summary info\n\n\ndinodata.head()\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.3846\n97.1795\n\n\n1\ndino\n51.5385\n96.0256\n\n\n2\ndino\n46.1538\n94.4872\n\n\n3\ndino\n42.8205\n91.4103\n\n\n4\ndino\n40.7692\n88.3333\n\n\n\n\n\n\n\n\ndinodata.tail()\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n1841\nwide_lines\n33.674442\n26.090490\n\n\n1842\nwide_lines\n75.627255\n37.128752\n\n\n1843\nwide_lines\n40.610125\n89.136240\n\n\n1844\nwide_lines\n39.114366\n96.481751\n\n\n1845\nwide_lines\n34.583829\n89.588902\n\n\n\n\n\n\n\n\ndinodata.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 1846 entries, 0 to 1845\nData columns (total 3 columns):\n #   Column   Non-Null Count  Dtype  \n---  ------   --------------  -----  \n 0   dataset  1846 non-null   object \n 1   x        1846 non-null   float64\n 2   y        1846 non-null   float64\ndtypes: float64(2), object(1)\nmemory usage: 43.4+ KB\n\n\nThere are several other useful dataframe attributes and methods that will allow you to get summary info: * columns : column names * dtypes : data types of the columns (dataframes can hold different datatypes in different columns) * index : information about the row indices (they don’t have to be numerical) * shape : the size of the dataframe in each dimension * describe() : basic statistics about the data columns\n\ndinodata.columns\n\nIndex(['dataset', 'x', 'y'], dtype='object')\n\n\n\ndinodata.dtypes\n\ndataset     object\nx          float64\ny          float64\ndtype: object\n\n\n\ndinodata.index\n\nRangeIndex(start=0, stop=1846, step=1)\n\n\n\ndinodata.shape\n\n(1846, 3)\n\n\n\ndinodata.describe()\n\n\n\n\n\n\n\n\nx\ny\n\n\n\n\ncount\n1846.000000\n1846.000000\n\n\nmean\n54.265695\n47.835099\n\n\nstd\n16.713001\n26.847766\n\n\nmin\n15.560750\n0.015119\n\n\n25%\n41.073403\n22.561073\n\n\n50%\n52.591269\n47.594450\n\n\n75%\n67.277845\n71.810778\n\n\nmax\n98.288123\n99.694680\n\n\n\n\n\n\n\n\ndinodata.describe(include = 'all')\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\ncount\n1846\n1846.000000\n1846.000000\n\n\nunique\n13\nNaN\nNaN\n\n\ntop\ndino\nNaN\nNaN\n\n\nfreq\n142\nNaN\nNaN\n\n\nmean\nNaN\n54.265695\n47.835099\n\n\nstd\nNaN\n16.713001\n26.847766\n\n\nmin\nNaN\n15.560750\n0.015119\n\n\n25%\nNaN\n41.073403\n22.561073\n\n\n50%\nNaN\n52.591269\n47.594450\n\n\n75%\nNaN\n67.277845\n71.810778\n\n\nmax\nNaN\n98.288123\n99.694680\n\n\n\n\n\n\n\nIf you select one of the columns of dinodata you’ll get a Series in return:\n\ndinodata['dataset']\n\n0             dino\n1             dino\n2             dino\n3             dino\n4             dino\n           ...    \n1841    wide_lines\n1842    wide_lines\n1843    wide_lines\n1844    wide_lines\n1845    wide_lines\nName: dataset, Length: 1846, dtype: object"
  },
  {
    "objectID": "posts/Session03_NB2_PandasDatasaurus.html#selecting-data-from-a-dataframe",
    "href": "posts/Session03_NB2_PandasDatasaurus.html#selecting-data-from-a-dataframe",
    "title": "PandasDatasaurus",
    "section": "Selecting data from a dataframe",
    "text": "Selecting data from a dataframe\nIf you have a dataframe df and want to look at a specific column columnname, use df['columnname']\n\ndinodata['x']\n\n0       55.384600\n1       51.538500\n2       46.153800\n3       42.820500\n4       40.769200\n          ...    \n1841    33.674442\n1842    75.627255\n1843    40.610125\n1844    39.114366\n1845    34.583829\nName: x, Length: 1846, dtype: float64\n\n\nDataframe can have both numerical- and label-based indices. There is specific data retrieval syntax that accommodates this.\n\n# This will give an error!\ndinodata[0]\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nFile ~/DH140/.venv/lib/python3.11/site-packages/pandas/core/indexes/base.py:3805, in Index.get_loc(self, key)\n   3804 try:\n-&gt; 3805     return self._engine.get_loc(casted_key)\n   3806 except KeyError as err:\n\nFile index.pyx:167, in pandas._libs.index.IndexEngine.get_loc()\n\nFile index.pyx:196, in pandas._libs.index.IndexEngine.get_loc()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7081, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7089, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nKeyError: 0\n\nThe above exception was the direct cause of the following exception:\n\nKeyError                                  Traceback (most recent call last)\nCell In[22], line 2\n      1 # This will give an error!\n----&gt; 2 dinodata[0]\n\nFile ~/DH140/.venv/lib/python3.11/site-packages/pandas/core/frame.py:4102, in DataFrame.__getitem__(self, key)\n   4100 if self.columns.nlevels &gt; 1:\n   4101     return self._getitem_multilevel(key)\n-&gt; 4102 indexer = self.columns.get_loc(key)\n   4103 if is_integer(indexer):\n   4104     indexer = [indexer]\n\nFile ~/DH140/.venv/lib/python3.11/site-packages/pandas/core/indexes/base.py:3812, in Index.get_loc(self, key)\n   3807     if isinstance(casted_key, slice) or (\n   3808         isinstance(casted_key, abc.Iterable)\n   3809         and any(isinstance(x, slice) for x in casted_key)\n   3810     ):\n   3811         raise InvalidIndexError(key)\n-&gt; 3812     raise KeyError(key) from err\n   3813 except TypeError:\n   3814     # If we have a listlike key, _check_indexing_error will raise\n   3815     #  InvalidIndexError. Otherwise we fall through and re-raise\n   3816     #  the TypeError.\n   3817     self._check_indexing_error(key)\n\nKeyError: 0\n\n\n\n\n# This will not give an error\ndinodata[0:1]\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.3846\n97.1795\n\n\n\n\n\n\n\nIt’s best to stick with loc and iloc for the moment to index dataframes. * loc : label-based indexing (which can look numerical if the row index is a number) * iloc : numerical indexing\n\n# the first row;\n# return value is a Series\n\ndinodata.loc[0]\n\ndataset       dino\nx          55.3846\ny          97.1795\nName: 0, dtype: object\n\n\n\n# the first row;\n# return value is a Dataframe (note the index is [0])\n\ndinodata.loc[[0]]\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.3846\n97.1795\n\n\n\n\n\n\n\n\n# the first two rows;\n# return value is a Dataframe (the index is a list [0,1])\n\ndinodata.loc[[0,1]]\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.3846\n97.1795\n\n\n1\ndino\n51.5385\n96.0256\n\n\n\n\n\n\n\n\n# indexing both the row and column\n\ndinodata.loc[0,'x']\n\n55.3846\n\n\n\n# indexing both the row and column\n# and returning a dataframe\n\ndinodata.loc[[0],['x']]\n\n\n\n\n\n\n\n\nx\n\n\n\n\n0\n55.3846\n\n\n\n\n\n\n\n\n# you can use lists for the indices\n\ndinodata.loc[[0],['x','y']]\n\n\n\n\n\n\n\n\nx\ny\n\n\n\n\n0\n55.3846\n97.1795\n\n\n\n\n\n\n\n\ndinodata.loc[[10],['x','y']]\n\n\n\n\n\n\n\n\nx\ny\n\n\n\n\n10\n23.0769\n66.4103\n\n\n\n\n\n\n\niloc is useful when you instead want to index numerically.\n\ndinodata.iloc[0]\n\ndataset       dino\nx          55.3846\ny          97.1795\nName: 0, dtype: object\n\n\nBefore you execute the below, try to predict whether it will return a Series or a Dataframe.\n\ndinodata.iloc[1]\n\ndataset       dino\nx          51.5385\ny          96.0256\nName: 1, dtype: object\n\n\n\ndinodata.iloc[[1]]\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n1\ndino\n51.5385\n96.0256\n\n\n\n\n\n\n\n\ndinodata.iloc[0:1]\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.3846\n97.1795\n\n\n\n\n\n\n\n\ndinodata.iloc[0:4]\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.3846\n97.1795\n\n\n1\ndino\n51.5385\n96.0256\n\n\n2\ndino\n46.1538\n94.4872\n\n\n3\ndino\n42.8205\n91.4103\n\n\n\n\n\n\n\n\n# this will give an error! you can't use a label-based index like 'x' with iloc\n\ndinodata.iloc[0:4,'x']\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nFile ~/DH140/.venv/lib/python3.11/site-packages/pandas/core/indexing.py:966, in _LocationIndexer._validate_tuple_indexer(self, key)\n    965 try:\n--&gt; 966     self._validate_key(k, i)\n    967 except ValueError as err:\n\nFile ~/DH140/.venv/lib/python3.11/site-packages/pandas/core/indexing.py:1614, in _iLocIndexer._validate_key(self, key, axis)\n   1613 else:\n-&gt; 1614     raise ValueError(f\"Can only index by location with a [{self._valid_types}]\")\n\nValueError: Can only index by location with a [integer, integer slice (START point is INCLUDED, END point is EXCLUDED), listlike of integers, boolean array]\n\nThe above exception was the direct cause of the following exception:\n\nValueError                                Traceback (most recent call last)\nCell In[36], line 3\n      1 # this will give an error! you can't use a label-based index like 'x' with iloc\n----&gt; 3 dinodata.iloc[0:4,'x']\n\nFile ~/DH140/.venv/lib/python3.11/site-packages/pandas/core/indexing.py:1184, in _LocationIndexer.__getitem__(self, key)\n   1182     if self._is_scalar_access(key):\n   1183         return self.obj._get_value(*key, takeable=self._takeable)\n-&gt; 1184     return self._getitem_tuple(key)\n   1185 else:\n   1186     # we by definition only have the 0th axis\n   1187     axis = self.axis or 0\n\nFile ~/DH140/.venv/lib/python3.11/site-packages/pandas/core/indexing.py:1690, in _iLocIndexer._getitem_tuple(self, tup)\n   1689 def _getitem_tuple(self, tup: tuple):\n-&gt; 1690     tup = self._validate_tuple_indexer(tup)\n   1691     with suppress(IndexingError):\n   1692         return self._getitem_lowerdim(tup)\n\nFile ~/DH140/.venv/lib/python3.11/site-packages/pandas/core/indexing.py:968, in _LocationIndexer._validate_tuple_indexer(self, key)\n    966         self._validate_key(k, i)\n    967     except ValueError as err:\n--&gt; 968         raise ValueError(\n    969             \"Location based indexing can only have \"\n    970             f\"[{self._valid_types}] types\"\n    971         ) from err\n    972 return key\n\nValueError: Location based indexing can only have [integer, integer slice (START point is INCLUDED, END point is EXCLUDED), listlike of integers, boolean array] types\n\n\n\n\n# instead of referncing the column with 'x'\n# iloc indexes it numerically\n\ndinodata.iloc[0:4, 1]\n\n0    55.3846\n1    51.5385\n2    46.1538\n3    42.8205\nName: x, dtype: float64\n\n\n\ndinodata.iloc[[0,1,2,3],[1]]\n\n\n\n\n\n\n\n\nx\n\n\n\n\n0\n55.3846\n\n\n1\n51.5385\n\n\n2\n46.1538\n\n\n3\n42.8205\n\n\n\n\n\n\n\n\ndinodata.iloc[0,0]\n\n'dino'\n\n\n\ndinodata.loc[0,'dataset']\n\n'dino'"
  },
  {
    "objectID": "posts/Session03_NB2_PandasDatasaurus.html#whats-the-data-for-dataset-dino-boolean-indexing",
    "href": "posts/Session03_NB2_PandasDatasaurus.html#whats-the-data-for-dataset-dino-boolean-indexing",
    "title": "PandasDatasaurus",
    "section": "What’s the data for ‘dataset’ == ‘dino’? Boolean indexing",
    "text": "What’s the data for ‘dataset’ == ‘dino’? Boolean indexing\nIt is useful to be able to get elements where certain conditions are true.\nLike here, we may want to get only those rows that are part of the ‘dino’ dataset.\nThis can be accomplished with boolean indexing, where the index is a True/False condition, and there is one such value for every row.\nThe following sets up the boolean series of True/False values for every row.\n\ndinodata['dataset'] == 'dino'\n\n0        True\n1        True\n2        True\n3        True\n4        True\n        ...  \n1841    False\n1842    False\n1843    False\n1844    False\n1845    False\nName: dataset, Length: 1846, dtype: bool\n\n\nWe can use that as the index to dinodata, i.e., for any dataframe df we can use df[condition] to get only those rows where condition is True\n\ndinodata[dinodata['dataset'] == 'dino']\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.3846\n97.1795\n\n\n1\ndino\n51.5385\n96.0256\n\n\n2\ndino\n46.1538\n94.4872\n\n\n3\ndino\n42.8205\n91.4103\n\n\n4\ndino\n40.7692\n88.3333\n\n\n...\n...\n...\n...\n\n\n137\ndino\n39.4872\n25.3846\n\n\n138\ndino\n91.2821\n41.5385\n\n\n139\ndino\n50.0000\n95.7692\n\n\n140\ndino\n47.9487\n95.0000\n\n\n141\ndino\n44.1026\n92.6923\n\n\n\n\n142 rows × 3 columns\n\n\n\nBoolean indexing also works as the index when using loc\n\ndinodata.loc[dinodata['dataset'] == 'dino']\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.3846\n97.1795\n\n\n1\ndino\n51.5385\n96.0256\n\n\n2\ndino\n46.1538\n94.4872\n\n\n3\ndino\n42.8205\n91.4103\n\n\n4\ndino\n40.7692\n88.3333\n\n\n...\n...\n...\n...\n\n\n137\ndino\n39.4872\n25.3846\n\n\n138\ndino\n91.2821\n41.5385\n\n\n139\ndino\n50.0000\n95.7692\n\n\n140\ndino\n47.9487\n95.0000\n\n\n141\ndino\n44.1026\n92.6923\n\n\n\n\n142 rows × 3 columns\n\n\n\n\ndinodata.loc[dinodata['dataset'] == 'circle']\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n1136\ncircle\n55.993030\n79.277264\n\n\n1137\ncircle\n50.032254\n79.013071\n\n\n1138\ncircle\n51.288459\n82.435940\n\n\n1139\ncircle\n51.170537\n79.165294\n\n\n1140\ncircle\n44.377915\n78.164628\n\n\n...\n...\n...\n...\n\n\n1273\ncircle\n39.921363\n19.701850\n\n\n1274\ncircle\n84.794278\n55.568650\n\n\n1275\ncircle\n55.662959\n83.356480\n\n\n1276\ncircle\n50.492248\n78.997532\n\n\n1277\ncircle\n51.467101\n79.201845\n\n\n\n\n142 rows × 3 columns\n\n\n\nNote above what happens to the indices. You should keep in mind this behavior if you want to index the returned result.\n\ndinodata.loc[dinodata['dataset'] == 'dino','x']\n\n0      55.3846\n1      51.5385\n2      46.1538\n3      42.8205\n4      40.7692\n        ...   \n137    39.4872\n138    91.2821\n139    50.0000\n140    47.9487\n141    44.1026\nName: x, Length: 142, dtype: float64\n\n\n\ndinodata['dataset'].str.startswith('d')\n\n0        True\n1        True\n2        True\n3        True\n4        True\n        ...  \n1841    False\n1842    False\n1843    False\n1844    False\n1845    False\nName: dataset, Length: 1846, dtype: bool\n\n\n\ndinodata.loc[dinodata['dataset'].str.startswith('d')]\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.384600\n97.179500\n\n\n1\ndino\n51.538500\n96.025600\n\n\n2\ndino\n46.153800\n94.487200\n\n\n3\ndino\n42.820500\n91.410300\n\n\n4\ndino\n40.769200\n88.333300\n\n\n...\n...\n...\n...\n\n\n1131\ndots\n50.533635\n17.019581\n\n\n1132\ndots\n77.500907\n50.166986\n\n\n1133\ndots\n50.691124\n87.513960\n\n\n1134\ndots\n49.990395\n83.997357\n\n\n1135\ndots\n50.127182\n82.990750\n\n\n\n\n284 rows × 3 columns\n\n\n\n\ndinodata.loc[dinodata['dataset'].str.contains('in')]\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.384600\n97.179500\n\n\n1\ndino\n51.538500\n96.025600\n\n\n2\ndino\n46.153800\n94.487200\n\n\n3\ndino\n42.820500\n91.410300\n\n\n4\ndino\n40.769200\n88.333300\n\n\n...\n...\n...\n...\n\n\n1841\nwide_lines\n33.674442\n26.090490\n\n\n1842\nwide_lines\n75.627255\n37.128752\n\n\n1843\nwide_lines\n40.610125\n89.136240\n\n\n1844\nwide_lines\n39.114366\n96.481751\n\n\n1845\nwide_lines\n34.583829\n89.588902\n\n\n\n\n710 rows × 3 columns\n\n\n\nDataframes have many very useful methods.\n… which we will ignore for the moment until next week when we get to exploratory data analysis.\nFor now: plotting!"
  },
  {
    "objectID": "posts/Session03_NB2_PandasDatasaurus.html#plotting",
    "href": "posts/Session03_NB2_PandasDatasaurus.html#plotting",
    "title": "PandasDatasaurus",
    "section": "Plotting",
    "text": "Plotting\nLet’s make a scatter plot with only the dino dataset\n\n# How do we get that subset of data?\n\na = dinodata[dinodata['dataset'] == 'dino']\n\nMake a plot:\n\na.plot(x='x', y='y')\n\n\n\n\n\n\n\n\nWhat’s with the zig-zags?\nBy default, pandas will make a line plot connecting the points, and since the points are plotted out of numerical order, the connecting lines zigs back and forth in the x and y direction.\nWe actually want to plot this as a scatter plot instead of a line plot.\n\na.plot(x='x', y='y', kind='scatter')\n\n\n\n\n\n\n\n\nThe kind parameter makes it very easy to make a variety of different elementary plots:\n\nline : line plot\nbar : vertical bar plot\nbarh : horizontal bar plot\nhist : histogram\nbox : boxplot\nkde : kernel density estimation plot\ndensity : same as kde\narea : area plot\npie : pie plot\nscatter : scatter plot\nhexbin : hexbin plot\n\n\na.plot(x='x', y='y', kind='bar')\n\n\n\n\n\n\n\n\nThis, of course, doesn’t mean that you don’t have to think about what you want to plot before-hand.\nTo make things easier, let’s look at a subset of data:\n\nb = a[0:15]\n\n\nb\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.3846\n97.1795\n\n\n1\ndino\n51.5385\n96.0256\n\n\n2\ndino\n46.1538\n94.4872\n\n\n3\ndino\n42.8205\n91.4103\n\n\n4\ndino\n40.7692\n88.3333\n\n\n5\ndino\n38.7179\n84.8718\n\n\n6\ndino\n35.6410\n79.8718\n\n\n7\ndino\n33.0769\n77.5641\n\n\n8\ndino\n28.9744\n74.4872\n\n\n9\ndino\n26.1538\n71.4103\n\n\n10\ndino\n23.0769\n66.4103\n\n\n11\ndino\n22.3077\n61.7949\n\n\n12\ndino\n22.3077\n57.1795\n\n\n13\ndino\n23.3333\n52.9487\n\n\n14\ndino\n25.8974\n51.0256\n\n\n\n\n\n\n\n\nb.plot(x='x', y='y', kind='bar')\n\n\n\n\n\n\n\n\nNote that pandas does not necessarily try to order the x-axis here for us.\n\nb.sort_values(by='x')\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n12\ndino\n22.3077\n57.1795\n\n\n11\ndino\n22.3077\n61.7949\n\n\n10\ndino\n23.0769\n66.4103\n\n\n13\ndino\n23.3333\n52.9487\n\n\n14\ndino\n25.8974\n51.0256\n\n\n9\ndino\n26.1538\n71.4103\n\n\n8\ndino\n28.9744\n74.4872\n\n\n7\ndino\n33.0769\n77.5641\n\n\n6\ndino\n35.6410\n79.8718\n\n\n5\ndino\n38.7179\n84.8718\n\n\n4\ndino\n40.7692\n88.3333\n\n\n3\ndino\n42.8205\n91.4103\n\n\n2\ndino\n46.1538\n94.4872\n\n\n1\ndino\n51.5385\n96.0256\n\n\n0\ndino\n55.3846\n97.1795\n\n\n\n\n\n\n\n\nb.sort_values(by='x').plot()\n\n\n\n\n\n\n\n\n\nb.sort_values(by='x').plot(x='x', y='y', kind='bar')\n\n\n\n\n\n\n\n\n\nb.sort_values(by='x').plot(x='x', y='y', kind='barh')\n\n\n\n\n\n\n\n\n\na.plot(x='x',\n       y='y',\n       kind='scatter')\n\n\n\n\n\n\n\n\n\na.plot(x='x',\n       y='y',\n       kind='scatter',\n       figsize=(5,5))\n\n\n\n\n\n\n\n\n\na.plot(x='x',\n       y='y',\n       kind='scatter',\n       figsize=(5,5),\n       xlabel='hdata',\n       ylabel='vdata')\n\n\n\n\n\n\n\n\n\na.plot(x='x',\n       y='y',\n       kind='scatter',\n       figsize=(5,5),\n       xlabel='hdata',\n       ylabel='vdata',\n       color='black')\n\n\n\n\n\n\n\n\n\ndinodata[dinodata['dataset']=='dino'].plot(x='x',\n       y='y',\n       kind='scatter',\n       figsize=(5,5),\n       xlabel='hdata',\n       ylabel='vdata',\n       color='black')\n\n\n\n\n\n\n\n\nWhat datasets can we look at?\n\ndinodata['dataset'].unique()\n\narray(['dino', 'away', 'h_lines', 'v_lines', 'x_shape', 'star',\n       'high_lines', 'dots', 'circle', 'bullseye', 'slant_up',\n       'slant_down', 'wide_lines'], dtype=object)\n\n\n\ndatasets = dinodata['dataset'].unique()\n\n\nd2plot = 3\n\nprint(datasets[d2plot])\n\ndinodata[dinodata['dataset'] == datasets[d2plot]].plot(x='x',\n       y='y',\n       kind='scatter',\n       figsize=(5,5),\n       xlabel='hdata',\n       ylabel='vdata',\n       color='black')\n\nv_lines"
  },
  {
    "objectID": "posts/Session03_NB2_PandasDatasaurus.html#brief-hint-of-fun-stuff-to-come",
    "href": "posts/Session03_NB2_PandasDatasaurus.html#brief-hint-of-fun-stuff-to-come",
    "title": "PandasDatasaurus",
    "section": "Brief hint of fun stuff to come",
    "text": "Brief hint of fun stuff to come\n\nimport matplotlib.pyplot as plt\nimport ipywidgets\n\n\ndef dinoplot(dataset):\n    fig,ax = plt.subplots(2,2,figsize=(12,12))\n    dinodata[dinodata['dataset']==dataset].plot(x='y',\n           y='x',\n           kind='hist',\n           figsize=(5,5),\n           xlabel='hdata',\n           ylabel='vdata',\n           color='black', ax=ax[0,0])\n    dinodata[dinodata['dataset']==dataset].plot(x='x',\n           y='y',\n           kind='scatter',\n           figsize=(5,5),\n           xlabel='hdata',\n           ylabel='vdata',\n           color='black', ax=ax[1,0])\n    ax[0,1].text(0.25,0.8,'x_mean = {:.2f}'.format(dinodata.loc[dinodata['dataset']==dataset,'x'].mean()))\n    ax[0,1].text(0.25,0.6,'y_mean = {:.2f}'.format(dinodata.loc[dinodata['dataset']==dataset,'y'].mean()))\n    ax[0,1].text(0.25,0.4,'x_stddev = {:.2f}'.format(dinodata.loc[dinodata['dataset']==dataset,'x'].std()))\n    ax[0,1].text(0.25,0.2,'y_stddev = {:.2f}'.format(dinodata.loc[dinodata['dataset']==dataset,'y'].std()))\n    dinodata[dinodata['dataset']==dataset].plot(x='x',\n           y='y',\n           kind='hist',\n           figsize=(5,5),\n           xlabel='hdata',\n           ylabel='vdata',\n           color='black', ax=ax[1,1])\n    \nipywidgets.interact(dinoplot,dataset=datasets)\n\n\n\n\n&lt;function __main__.dinoplot(dataset)&gt;"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/pokemon_analysis.html",
    "href": "posts/pokemon_analysis.html",
    "title": "PokéMetrics: Analyzing Stats and Type Effectiveness",
    "section": "",
    "text": "By Rachel Truong\nPublished August 2, 2024\n\n\nThe Pokemon games are centered around battling others with a team of “pocket monsters,” hence the name of the franchise. With a predetermined set of stats and moves for each of their monster partners, players direct their Pokemon in battle and struggle against other Pokemon trainers to make their way to becoming the champion of the Pokemon world. These stats and decisions ultimately become the deciding factor in who emerges victorious. Thus, it is important for players to understand the stats and inner mechanics of the game. However, the game is a gem of childhood for many, and as children, many had simply played the game without paying much attention to stats and numbers. Of course, the game is designed well and can be played as such, but having played the game in that manner, I struggled. My Pokemon were okay, but were never strong enough for my liking. Of course, having played for so long, I eventually figured out through trial and error which Pokemon were stronger than others, but playing more and more, I find that I still struggle with picking better Pokemon to use.\n\n\nBut now, equipped with time and data, I wanted to take the opportunity to do a data-driven approach towards analyzing the differences in strength between Pokémon through comparing their base stats. I’ve never done an in-depth analysis before, as I simply have just played the game and choosing Pokemon that I liked and thought would do the job. Just last week I was casually playing, but my pokemon kept dying on me right next to the entrance of the next town.\n\n\n\nFor this project, I will be using PokeAPI, an API linked to multiple databases detailing everything about the Pokémon main game series. I will be specifically be using data from these databases: | Dataset | Description | Link | |———|—————————————————————————————————–|————————————————| | Pokemon | Database of all pokemon that exist in the game, as well as their stats | API Docs | | Types | Database of the pokemon types, and anything that relates to them (type effectiveness, Pokemon, etc) | API Docs |\n\n\n\n\nWhich type combination are good to have?\nWhich Pokemon have the best stats?\n\nWhat is the best Pokemon to carry on you when running into random Pokemon and enemy trainers?\n\n\n\n\n\n\n\nThe following libraries that this project uses. If you are accessing this project through the binder, they should be already installed, otherwise you should run the following cell.\n\nimport pandas as pd\nimport json\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport requests\n\n\n\n\nBecause I am using an API designed to just give you the complete data about specific things in pokemon, I have to call the API multiple times: first to get the list of items, and then X amount of times to get each specific record/row. Once I get each record, I store it in their respective dataframe: poke_df for pokemon and type_df for types.\n\n# Function to retrieve data from the API\ndef retrieve_data(url):\n    # Getting the list of all Pokemon\n    response = requests.get(url)\n    url_list = response.json()['results']\n\n    # Getting the data for each item\n    details = []\n    for url in url_list:\n        response = requests.get(url['url'])\n        details.append(response.json())\n\n    # Converting data to DataFrame\n    return pd.DataFrame(details)\n\n\n# Getting the list of all Pokemon \nplist_url = \"https://pokeapi.co/api/v2/pokemon?limit=1302&offset=0\"\npoke_df = retrieve_data(plist_url)\n\n# Getting the list of all Pokemon types\ntlist_url = \"https://pokeapi.co/api/v2/type?limit=21&offset=0\"\ntype_df = retrieve_data(tlist_url)\n\n\"\"\"\n# Saving the data to a csv file (for cache reasons)\npoke_df.to_json('data/pokemon_data.json', orient='records', lines=True)\ntype_df.to_json('data/type_data.json', orient='records', lines=True)\n\"\"\"\n\n\"\\n# Saving the data to a csv file (for cache reasons)\\npoke_df.to_json('data/pokemon_data.json', orient='records', lines=True)\\ntype_df.to_json('data/type_data.json', orient='records', lines=True)\\n\"\n\n\nAt the end of the previous block, I previously downloaded the data frames I fetched (code is in comments). This is so in the future if the database is modified, someone else running this project can see what I got now. In order to run using that data, you can uncomment and run the following block.\n\n\"\"\"\n# Loading the data from the csv file\npoke_df = pd.read_json('data/pokemon_data.json', orient='records', lines=True)\ntype_df = pd.read_json('data/type_data.json', orient='records', lines=True)\n\"\"\"\n\n\"\\n# Loading the data from the csv file\\npoke_df = pd.read_json('data/pokemon_data.json', orient='records', lines=True)\\ntype_df = pd.read_json('data/type_data.json', orient='records', lines=True)\\n\"\n\n\n\n\n\nOnce you download the data, it’s a good idea to check what the data you are working with looks like. I do so by using .head().\n\npoke_df.head()\n\n\n\n\n\n\n\n\nabilities\nbase_experience\ncries\nforms\ngame_indices\nheight\nheld_items\nid\nis_default\nlocation_area_encounters\nmoves\nname\norder\npast_abilities\npast_types\nspecies\nsprites\nstats\ntypes\nweight\n\n\n\n\n0\n[{'ability': {'name': 'overgrow', 'url': 'http...\n64.0\n{'latest': 'https://raw.githubusercontent.com/...\n[{'name': 'bulbasaur', 'url': 'https://pokeapi...\n[{'game_index': 153, 'version': {'name': 'red'...\n7\n[]\n1\nTrue\nhttps://pokeapi.co/api/v2/pokemon/1/encounters\n[{'move': {'name': 'razor-wind', 'url': 'https...\nbulbasaur\n1\n[]\n[]\n{'name': 'bulbasaur', 'url': 'https://pokeapi....\n{'back_default': 'https://raw.githubuserconten...\n[{'base_stat': 45, 'effort': 0, 'stat': {'name...\n[{'slot': 1, 'type': {'name': 'grass', 'url': ...\n69\n\n\n1\n[{'ability': {'name': 'overgrow', 'url': 'http...\n142.0\n{'latest': 'https://raw.githubusercontent.com/...\n[{'name': 'ivysaur', 'url': 'https://pokeapi.c...\n[{'game_index': 9, 'version': {'name': 'red', ...\n10\n[]\n2\nTrue\nhttps://pokeapi.co/api/v2/pokemon/2/encounters\n[{'move': {'name': 'swords-dance', 'url': 'htt...\nivysaur\n2\n[]\n[]\n{'name': 'ivysaur', 'url': 'https://pokeapi.co...\n{'back_default': 'https://raw.githubuserconten...\n[{'base_stat': 60, 'effort': 0, 'stat': {'name...\n[{'slot': 1, 'type': {'name': 'grass', 'url': ...\n130\n\n\n2\n[{'ability': {'name': 'overgrow', 'url': 'http...\n263.0\n{'latest': 'https://raw.githubusercontent.com/...\n[{'name': 'venusaur', 'url': 'https://pokeapi....\n[{'game_index': 154, 'version': {'name': 'red'...\n20\n[]\n3\nTrue\nhttps://pokeapi.co/api/v2/pokemon/3/encounters\n[{'move': {'name': 'swords-dance', 'url': 'htt...\nvenusaur\n3\n[]\n[]\n{'name': 'venusaur', 'url': 'https://pokeapi.c...\n{'back_default': 'https://raw.githubuserconten...\n[{'base_stat': 80, 'effort': 0, 'stat': {'name...\n[{'slot': 1, 'type': {'name': 'grass', 'url': ...\n1000\n\n\n3\n[{'ability': {'name': 'blaze', 'url': 'https:/...\n62.0\n{'latest': 'https://raw.githubusercontent.com/...\n[{'name': 'charmander', 'url': 'https://pokeap...\n[{'game_index': 176, 'version': {'name': 'red'...\n6\n[]\n4\nTrue\nhttps://pokeapi.co/api/v2/pokemon/4/encounters\n[{'move': {'name': 'mega-punch', 'url': 'https...\ncharmander\n5\n[]\n[]\n{'name': 'charmander', 'url': 'https://pokeapi...\n{'back_default': 'https://raw.githubuserconten...\n[{'base_stat': 39, 'effort': 0, 'stat': {'name...\n[{'slot': 1, 'type': {'name': 'fire', 'url': '...\n85\n\n\n4\n[{'ability': {'name': 'blaze', 'url': 'https:/...\n142.0\n{'latest': 'https://raw.githubusercontent.com/...\n[{'name': 'charmeleon', 'url': 'https://pokeap...\n[{'game_index': 178, 'version': {'name': 'red'...\n11\n[]\n5\nTrue\nhttps://pokeapi.co/api/v2/pokemon/5/encounters\n[{'move': {'name': 'mega-punch', 'url': 'https...\ncharmeleon\n6\n[]\n[]\n{'name': 'charmeleon', 'url': 'https://pokeapi...\n{'back_default': 'https://raw.githubuserconten...\n[{'base_stat': 58, 'effort': 0, 'stat': {'name...\n[{'slot': 1, 'type': {'name': 'fire', 'url': '...\n190\n\n\n\n\n\n\n\n\ntype_df.head()\n\n\n\n\n\n\n\n\ndamage_relations\ngame_indices\ngeneration\nid\nmove_damage_class\nmoves\nname\nnames\npast_damage_relations\npokemon\n\n\n\n\n0\n{'double_damage_from': [{'name': 'fighting', '...\n[{'game_index': 0, 'generation': {'name': 'gen...\n{'name': 'generation-i', 'url': 'https://pokea...\n1\n{'name': 'physical', 'url': 'https://pokeapi.c...\n[{'name': 'pound', 'url': 'https://pokeapi.co/...\nnormal\n[{'language': {'name': 'ja-Hrkt', 'url': 'http...\n[]\n[{'pokemon': {'name': 'pidgey', 'url': 'https:...\n\n\n1\n{'double_damage_from': [{'name': 'flying', 'ur...\n[{'game_index': 1, 'generation': {'name': 'gen...\n{'name': 'generation-i', 'url': 'https://pokea...\n2\n{'name': 'physical', 'url': 'https://pokeapi.c...\n[{'name': 'karate-chop', 'url': 'https://pokea...\nfighting\n[{'language': {'name': 'ja-Hrkt', 'url': 'http...\n[]\n[{'pokemon': {'name': 'mankey', 'url': 'https:...\n\n\n2\n{'double_damage_from': [{'name': 'rock', 'url'...\n[{'game_index': 2, 'generation': {'name': 'gen...\n{'name': 'generation-i', 'url': 'https://pokea...\n3\n{'name': 'physical', 'url': 'https://pokeapi.c...\n[{'name': 'gust', 'url': 'https://pokeapi.co/a...\nflying\n[{'language': {'name': 'ja-Hrkt', 'url': 'http...\n[]\n[{'pokemon': {'name': 'charizard', 'url': 'htt...\n\n\n3\n{'double_damage_from': [{'name': 'ground', 'ur...\n[{'game_index': 3, 'generation': {'name': 'gen...\n{'name': 'generation-i', 'url': 'https://pokea...\n4\n{'name': 'physical', 'url': 'https://pokeapi.c...\n[{'name': 'poison-sting', 'url': 'https://poke...\npoison\n[{'language': {'name': 'ja-Hrkt', 'url': 'http...\n[{'damage_relations': {'double_damage_from': [...\n[{'pokemon': {'name': 'bulbasaur', 'url': 'htt...\n\n\n4\n{'double_damage_from': [{'name': 'water', 'url...\n[{'game_index': 4, 'generation': {'name': 'gen...\n{'name': 'generation-i', 'url': 'https://pokea...\n5\n{'name': 'physical', 'url': 'https://pokeapi.c...\n[{'name': 'sand-attack', 'url': 'https://pokea...\nground\n[{'language': {'name': 'ja-Hrkt', 'url': 'http...\n[]\n[{'pokemon': {'name': 'sandshrew', 'url': 'htt...\n\n\n\n\n\n\n\nWe can see that theres a lot of JSON data in there that isn’t very useful for analysis right off the bat. Because I only want data in specific columns (‘type’ and ‘stats’ in poke_df and ‘damage_relations’ in type_df), I’ll just process the data in those columns.\n\n# Looking at what values in poke_df['types'] look like\npoke_df['types'][0]\n\n[{'slot': 1,\n  'type': {'name': 'grass', 'url': 'https://pokeapi.co/api/v2/type/12/'}},\n {'slot': 2,\n  'type': {'name': 'poison', 'url': 'https://pokeapi.co/api/v2/type/4/'}}]\n\n\nFor ‘types’ in poke_df, because we are just getting the values of all type.name, we just search for the values in the JSON and save it as a list. I chose not to do it as 2 columns as it would result in null values, which I think would make more work later for me when making data visualizations, so I just replaced the original value with the new list.\n\n# Extra every type name into list for each Pokemon and replace the 'types' column\ntypes_array = []\nfor val in poke_df['types']:\n    types = []\n    for attr in val: \n        types.append(attr['type']['name'])\n    types_array.append(types)\n\npoke_df['types'] = types_array\npoke_df['types'].head()\n\n0    [grass, poison]\n1    [grass, poison]\n2    [grass, poison]\n3             [fire]\n4             [fire]\nName: types, dtype: object\n\n\n\n# Looking at what values in poke_df['stats'] look like\npoke_df['stats'][0]\n\n[{'base_stat': 45,\n  'effort': 0,\n  'stat': {'name': 'hp', 'url': 'https://pokeapi.co/api/v2/stat/1/'}},\n {'base_stat': 49,\n  'effort': 0,\n  'stat': {'name': 'attack', 'url': 'https://pokeapi.co/api/v2/stat/2/'}},\n {'base_stat': 49,\n  'effort': 0,\n  'stat': {'name': 'defense', 'url': 'https://pokeapi.co/api/v2/stat/3/'}},\n {'base_stat': 65,\n  'effort': 1,\n  'stat': {'name': 'special-attack',\n   'url': 'https://pokeapi.co/api/v2/stat/4/'}},\n {'base_stat': 65,\n  'effort': 0,\n  'stat': {'name': 'special-defense',\n   'url': 'https://pokeapi.co/api/v2/stat/5/'}},\n {'base_stat': 45,\n  'effort': 0,\n  'stat': {'name': 'speed', 'url': 'https://pokeapi.co/api/v2/stat/6/'}}]\n\n\nFor ‘stats’ in poke_df, I wanted the name of the stat as well as its value (a int) so I just directly made a dictionary and set the key-value there as normal. Then I collected all the dictionaries into a list, turned the list into a data frame, and merged the new data frame with the original.\n\n# Extract the stat.name and base_stat into a list of dictionaries for each Pokemon\n# Also while having all the stats for a row/Pokemon, calculate the total stats\nstats_df = []\nfor val in poke_df['stats']:\n    stats = {}\n    for attr in val:\n        stats[attr['stat']['name']] = attr['base_stat']\n    stats[\"total\"] = sum(stats.values())\n    stats_df.append(stats)\n \n# Convert stats into a Pandas dataframe and merge with the original df\nstats_df = pd.DataFrame(stats_df)\npoke_df = pd.concat([poke_df, stats_df], axis=1)\npoke_df[['hp', 'attack', 'defense', 'speed', 'special-attack', 'special-defense', 'total']].head()\n\n\n\n\n\n\n\n\nhp\nattack\ndefense\nspeed\nspecial-attack\nspecial-defense\ntotal\n\n\n\n\n0\n45\n49\n49\n45\n65\n65\n318\n\n\n1\n60\n62\n63\n60\n80\n80\n405\n\n\n2\n80\n82\n83\n80\n100\n100\n525\n\n\n3\n39\n52\n43\n65\n60\n50\n309\n\n\n4\n58\n64\n58\n80\n80\n65\n405\n\n\n\n\n\n\n\n\n# looking at what values in type_df['damage_relations'] look like\ntype_df['damage_relations'][0]\n\n{'double_damage_from': [{'name': 'fighting',\n   'url': 'https://pokeapi.co/api/v2/type/2/'}],\n 'double_damage_to': [],\n 'half_damage_from': [],\n 'half_damage_to': [{'name': 'rock',\n   'url': 'https://pokeapi.co/api/v2/type/6/'},\n  {'name': 'steel', 'url': 'https://pokeapi.co/api/v2/type/9/'}],\n 'no_damage_from': [{'name': 'ghost',\n   'url': 'https://pokeapi.co/api/v2/type/8/'}],\n 'no_damage_to': [{'name': 'ghost',\n   'url': 'https://pokeapi.co/api/v2/type/8/'}]}\n\n\nFor the damage relations in type_df, I wanted to extract out the name of the type of damage and keep it as the column name, and the values in the column to be a list of the corresponding relation, so I first made a dictionary, converted the values into a list, made the key-value pairs. Then I put all the dictionaries into a list, turned it into a data frame and merged it with the original one.\n\n# get type names for set difference for normal damage\ntype_names = type_df['name'].values\n\n# extract each damage relation + data into list of dicts for each type\ndmg_df = [] \nfor val in type_df['damage_relations']:\n    t_looked = []                           # for keeping check which we have looked at \n    \n    # looks at attributes for damage multiplier\n    damage = {}\n    for attr in val:     \n        # extract the type names in damage multiplier data                   \n        type_list = []\n        for type_ in val[attr]:  \n            type_list.append(type_['name'])\n            if attr[-2:] == 'to':\n                t_looked.append(type_['name'])\n                # keep track of which types we have looked at in to \n                # no look at from because we dont need to double count\n\n        damage[attr] = type_list\n    \n    # added attr of normal damage and the values that should be in there\n    damage['normal_damage_to'] = list(set(type_names) - set(t_looked))\n\n    dmg_df.append(damage)\n\n# Convert damage into a Pandas dataframe and merge with the original df\ndmg_df = pd.DataFrame(dmg_df)\ntype_df = pd.concat([type_df, dmg_df], axis=1)\ntype_df[['double_damage_from', 'double_damage_to', 'half_damage_from', 'half_damage_to', 'no_damage_from', 'no_damage_to', 'normal_damage_to']].head()\n        \n\n\n\n\n\n\n\n\ndouble_damage_from\ndouble_damage_to\nhalf_damage_from\nhalf_damage_to\nno_damage_from\nno_damage_to\nnormal_damage_to\n\n\n\n\n0\n[fighting]\n[]\n[]\n[rock, steel]\n[ghost]\n[ghost]\n[poison, fairy, dragon, unknown, water, electr...\n\n\n1\n[flying, psychic, fairy]\n[normal, rock, steel, ice, dark]\n[rock, bug, dark]\n[flying, poison, bug, psychic, fairy]\n[]\n[ghost]\n[electric, shadow, fighting, fire, dragon, gro...\n\n\n2\n[rock, electric, ice]\n[fighting, bug, grass]\n[fighting, bug, grass]\n[rock, steel, electric]\n[ground]\n[]\n[shadow, poison, fairy, normal, dark, psychic,...\n\n\n3\n[ground, psychic]\n[grass, fairy]\n[fighting, poison, bug, grass, fairy]\n[poison, ground, rock, ghost]\n[]\n[steel]\n[electric, shadow, normal, dark, bug, psychic,...\n\n\n4\n[water, grass, ice]\n[poison, rock, steel, fire, electric]\n[poison, rock]\n[bug, grass]\n[electric]\n[flying]\n[shadow, fairy, normal, dark, psychic, ice, dr...\n\n\n\n\n\n\n\n\n\n\nNow that we have process all the necessary data, we can drop all the other columns that are unnecessary.\n\npoke_df = poke_df[['name', 'types', 'hp', 'attack', 'defense', 'speed', 'special-attack', 'special-defense', 'total']]\npoke_df.head()\n\n\n\n\n\n\n\n\nname\ntypes\nhp\nattack\ndefense\nspeed\nspecial-attack\nspecial-defense\ntotal\n\n\n\n\n0\nbulbasaur\n[grass, poison]\n45\n49\n49\n45\n65\n65\n318\n\n\n1\nivysaur\n[grass, poison]\n60\n62\n63\n60\n80\n80\n405\n\n\n2\nvenusaur\n[grass, poison]\n80\n82\n83\n80\n100\n100\n525\n\n\n3\ncharmander\n[fire]\n39\n52\n43\n65\n60\n50\n309\n\n\n4\ncharmeleon\n[fire]\n58\n64\n58\n80\n80\n65\n405\n\n\n\n\n\n\n\n\ntype_df = type_df[['name', 'double_damage_to', 'normal_damage_to', 'half_damage_to', 'no_damage_to']]\ntype_df.head() \n\n\n\n\n\n\n\n\nname\ndouble_damage_to\nnormal_damage_to\nhalf_damage_to\nno_damage_to\n\n\n\n\n0\nnormal\n[]\n[poison, fairy, dragon, unknown, water, electr...\n[rock, steel]\n[ghost]\n\n\n1\nfighting\n[normal, rock, steel, ice, dark]\n[electric, shadow, fighting, fire, dragon, gro...\n[flying, poison, bug, psychic, fairy]\n[ghost]\n\n\n2\nflying\n[fighting, bug, grass]\n[shadow, poison, fairy, normal, dark, psychic,...\n[rock, steel, electric]\n[]\n\n\n3\npoison\n[grass, fairy]\n[electric, shadow, normal, dark, bug, psychic,...\n[poison, ground, rock, ghost]\n[steel]\n\n\n4\nground\n[poison, rock, steel, fire, electric]\n[shadow, fairy, normal, dark, psychic, ice, dr...\n[bug, grass]\n[flying]\n\n\n\n\n\n\n\nAs a precaution, we should check and remove any rows that are missing data (NA, NaN, null).\n\npoke_df.isnull().sum()\n# no need to call dropna() as there are no nulls\n\nname               0\ntypes              0\nhp                 0\nattack             0\ndefense            0\nspeed              0\nspecial-attack     0\nspecial-defense    0\ntotal              0\ndtype: int64\n\n\n\ntype_df.isnull().sum()\n# also no need to call dropna()\n\nname                0\ndouble_damage_to    0\nnormal_damage_to    0\nhalf_damage_to      0\nno_damage_to        0\ndtype: int64\n\n\n\n\n\n\n\nTo get a quick overview of the the data, I ran both .info() and .describe() on the data frames.\n\npoke_df.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 1302 entries, 0 to 1301\nData columns (total 9 columns):\n #   Column           Non-Null Count  Dtype \n---  ------           --------------  ----- \n 0   name             1302 non-null   object\n 1   types            1302 non-null   object\n 2   hp               1302 non-null   int64 \n 3   attack           1302 non-null   int64 \n 4   defense          1302 non-null   int64 \n 5   speed            1302 non-null   int64 \n 6   special-attack   1302 non-null   int64 \n 7   special-defense  1302 non-null   int64 \n 8   total            1302 non-null   int64 \ndtypes: int64(7), object(2)\nmemory usage: 91.7+ KB\n\n\n\npoke_df.describe()\n\n\n\n\n\n\n\n\nhp\nattack\ndefense\nspeed\nspecial-attack\nspecial-defense\ntotal\n\n\n\n\ncount\n1302.000000\n1302.000000\n1302.000000\n1302.000000\n1302.000000\n1302.000000\n1302.000000\n\n\nmean\n71.264977\n81.580645\n75.241935\n71.156682\n73.649002\n72.966974\n445.860215\n\n\nstd\n26.764202\n31.673015\n30.492559\n30.310259\n32.469611\n27.358069\n119.865940\n\n\nmin\n1.000000\n5.000000\n5.000000\n5.000000\n10.000000\n20.000000\n175.000000\n\n\n25%\n54.000000\n58.000000\n53.000000\n48.000000\n50.000000\n52.000000\n335.000000\n\n\n50%\n70.000000\n80.000000\n70.000000\n70.000000\n65.000000\n70.000000\n470.000000\n\n\n75%\n85.000000\n100.000000\n95.000000\n92.000000\n95.000000\n90.000000\n525.000000\n\n\nmax\n255.000000\n190.000000\n250.000000\n200.000000\n194.000000\n250.000000\n1125.000000\n\n\n\n\n\n\n\nLooking at the Pokemon Data, there seems to be outliers towards the maximum, as they seem to have a standard distribution way higher than the rest. This is expected, as I believe that the points at the further end are probably some legendary Pokemon, which tends to be stronger because they tend to represent the “gods” of the Pokemon world.\n\n\n\nIn order to get a more in depth view of Pokemon stats, I decided to draw up all the distribution of each of the individual stats.\n\n# Create 3x3 grid of subplots\nfig, axs = plt.subplots(3, 3, figsize=(15, 15)) \nfig.suptitle('Pokemon Stats Distributions')\n\n# Plot 1: Histogram of HP\naxs[0, 0].hist(poke_df['hp'], color='blue')\naxs[0, 0].set_title('HP Distribution')\naxs[0, 0].set_xlabel('HP')\naxs[0, 0].set_ylabel('Frequency')\n\n# Plot 2: Histogram of Attack\naxs[0, 1].hist(poke_df['attack'], color='green')\naxs[0, 1].set_title('Attack Distribution')\naxs[0, 1].set_xlabel('Attack')\naxs[0, 1].set_ylabel('Frequency')\n\n# Plot 3: Histogram of Defense\naxs[0, 2].hist(poke_df['defense'], color='red')\naxs[0, 2].set_title('Defense Distribution')\naxs[0, 2].set_xlabel('Defense')\naxs[0, 2].set_ylabel('Frequency')\n\n# Plot 4: Histogram of Speed\naxs[1, 0].hist(poke_df['speed'], color='purple')\naxs[1, 0].set_title('Speed Distribution')\naxs[1, 0].set_xlabel('Speed')\naxs[1, 0].set_ylabel('Frequency')\n\n# Plot 5: Histogram of Special Attack\naxs[1, 1].hist(poke_df['special-attack'], color='orange')\naxs[1, 1].set_title('Special Attack Distribution')\naxs[1, 1].set_xlabel('Special Attack')\naxs[1, 1].set_ylabel('Frequency')\n\n# Plot 6: Histogram of Special Defense\naxs[1, 2].hist(poke_df['special-defense'], color='brown')\naxs[1, 2].set_title('Special Defense Distribution')\naxs[1, 2].set_xlabel('Special Defense')\naxs[1, 2].set_ylabel('Frequency')\n\n# Plot 7: Histogram of Total Stats\naxs[2, 1].hist(poke_df['total'], color='black')\naxs[2, 1].set_title('Total Stats Distribution')\naxs[2, 1].set_xlabel('Total Stats')\naxs[2, 1].set_ylabel('Frequency')\n\n# Adjust layout to prevent overlap and show plots\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nAs you can see, a lot of of the stats seem to be skewed a little bit to the left. In addition, there are multiple plots with 2 peaks, suggesting that there are possible 2 subgroups of pokemon in here.\n\n\n\nI decided to make heatmap of the effectiveness of each pokemon to see where possibly there might be a good indicator of which type matchup would be best. In order to make it, I made a n x n data frame based on how much damage an attacking type (row) would do against a defending type(column). As for the value in each cell, I set as the scale that an attack would change based on the type effectiveness that the attacker would deal.\n\n# Initialize an empty DataFrame with attackers as rows and defenders as columns\natk_x_def = pd.DataFrame(0.0, index=type_names, columns=type_names)\n\n# Fill in df based on relations in type_df\nfor row in type_df.iterrows():\n    for col in type_names:        \n        if col in row[1]['double_damage_to']:\n            atk_x_def.loc[row[1]['name'], col] = 2.0\n        elif col in row[1]['half_damage_to']:\n            atk_x_def.loc[row[1]['name'], col] = 0.5\n        elif col in row[1]['no_damage_to']:\n            atk_x_def.loc[row[1]['name'], col] = 0\n        else:\n            atk_x_def.loc[row[1]['name'], col] = 1.0       \n        \n# Display the resulting DataFrame\natk_x_def\n\n\n\n\n\n\n\n\nnormal\nfighting\nflying\npoison\nground\nrock\nbug\nghost\nsteel\nfire\n...\ngrass\nelectric\npsychic\nice\ndragon\ndark\nfairy\nstellar\nunknown\nshadow\n\n\n\n\nnormal\n1.0\n1.0\n1.0\n1.0\n1.0\n0.5\n1.0\n0.0\n0.5\n1.0\n...\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\nfighting\n2.0\n1.0\n0.5\n0.5\n1.0\n2.0\n0.5\n0.0\n2.0\n1.0\n...\n1.0\n1.0\n0.5\n2.0\n1.0\n2.0\n0.5\n1.0\n1.0\n1.0\n\n\nflying\n1.0\n2.0\n1.0\n1.0\n1.0\n0.5\n2.0\n1.0\n0.5\n1.0\n...\n2.0\n0.5\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\npoison\n1.0\n1.0\n1.0\n0.5\n0.5\n0.5\n1.0\n0.5\n0.0\n1.0\n...\n2.0\n1.0\n1.0\n1.0\n1.0\n1.0\n2.0\n1.0\n1.0\n1.0\n\n\nground\n1.0\n1.0\n0.0\n2.0\n1.0\n2.0\n0.5\n1.0\n2.0\n2.0\n...\n0.5\n2.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\nrock\n1.0\n0.5\n2.0\n1.0\n0.5\n1.0\n2.0\n1.0\n0.5\n2.0\n...\n1.0\n1.0\n1.0\n2.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\nbug\n1.0\n0.5\n0.5\n0.5\n1.0\n1.0\n1.0\n0.5\n0.5\n0.5\n...\n2.0\n1.0\n2.0\n1.0\n1.0\n2.0\n0.5\n1.0\n1.0\n1.0\n\n\nghost\n0.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n2.0\n1.0\n1.0\n...\n1.0\n1.0\n2.0\n1.0\n1.0\n0.5\n1.0\n1.0\n1.0\n1.0\n\n\nsteel\n1.0\n1.0\n1.0\n1.0\n1.0\n2.0\n1.0\n1.0\n0.5\n0.5\n...\n1.0\n0.5\n1.0\n2.0\n1.0\n1.0\n2.0\n1.0\n1.0\n1.0\n\n\nfire\n1.0\n1.0\n1.0\n1.0\n1.0\n0.5\n2.0\n1.0\n2.0\n0.5\n...\n2.0\n1.0\n1.0\n2.0\n0.5\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\nwater\n1.0\n1.0\n1.0\n1.0\n2.0\n2.0\n1.0\n1.0\n1.0\n2.0\n...\n0.5\n1.0\n1.0\n1.0\n0.5\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\ngrass\n1.0\n1.0\n0.5\n0.5\n2.0\n2.0\n0.5\n1.0\n0.5\n0.5\n...\n0.5\n1.0\n1.0\n1.0\n0.5\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\nelectric\n1.0\n1.0\n2.0\n1.0\n0.0\n1.0\n1.0\n1.0\n1.0\n1.0\n...\n0.5\n0.5\n1.0\n1.0\n0.5\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\npsychic\n1.0\n2.0\n1.0\n2.0\n1.0\n1.0\n1.0\n1.0\n0.5\n1.0\n...\n1.0\n1.0\n0.5\n1.0\n1.0\n0.0\n1.0\n1.0\n1.0\n1.0\n\n\nice\n1.0\n1.0\n2.0\n1.0\n2.0\n1.0\n1.0\n1.0\n0.5\n0.5\n...\n2.0\n1.0\n1.0\n0.5\n2.0\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\ndragon\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n0.5\n1.0\n...\n1.0\n1.0\n1.0\n1.0\n2.0\n1.0\n0.0\n1.0\n1.0\n1.0\n\n\ndark\n1.0\n0.5\n1.0\n1.0\n1.0\n1.0\n1.0\n2.0\n1.0\n1.0\n...\n1.0\n1.0\n2.0\n1.0\n1.0\n0.5\n0.5\n1.0\n1.0\n1.0\n\n\nfairy\n1.0\n2.0\n1.0\n0.5\n1.0\n1.0\n1.0\n1.0\n0.5\n0.5\n...\n1.0\n1.0\n1.0\n1.0\n2.0\n2.0\n1.0\n1.0\n1.0\n1.0\n\n\nstellar\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n...\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\nunknown\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n...\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\nshadow\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n...\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\n\n\n21 rows × 21 columns\n\n\n\nOnce my data frame was made, using the seaborn package, I plotted the heatmap using the coolwarm to show a clear color difference from when it doing more damage verse less, with white being no change.\n\nplt.figure(figsize=(10, 10))\nsns.heatmap(atk_x_def, annot=True, cmap='coolwarm')\nplt.title('Damage Multiplier Heatmap')\nplt.ylabel('Attacker Type')\nplt.xlabel('Defender Type')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nUsing this graph, it makes it easier to identify the weakness nad strengths of a pokemon, however you can’t really identify any clear patterns as to which is clearly the superior type. (This is relevant)\n\n\n\n\n\n\n\nIn order to make analyzing typings easier, I’m going to say that the overall effectiveness score is a sum of all the individual scores for each type. The more effective a type will be, the higher the score. I can think of 2 ways to compute the score.\nThe first way is to measure how effective a Pokemon’s moves would be against any other type. To calculate each individual score, I determined that choosing the more effective type of the Pokemon were against any other type. I decided to find the max because in the games, a Pokemon move can only be one type.\n\n# Score for effectiveness of their attacks\n# Higher score, the better the attack\natker = []\nfor pokemon in poke_df.iterrows():\n    scores = []\n    for type_ in pokemon[1]['types']:                       # calculate a score for each type\n        scores.append(atk_x_def.loc[type_].sum())\n    atker.append((pokemon[1]['name'], max(scores)))         # max because attacks are one type\n\nThe other way is to measure how much damage the Pokemon can resist when they are attacked by a specific type of move. I calculated this using the product of the scores that the attacking type would deal based on the defending Pokemon’s typing, just like in game.\n\n# Score based on the effectiveness of their defenses\n# Lower score, the better the defense\ndefer = []\nfor pokemon in poke_df.iterrows():\n    scores = []\n    for type_ in type_names:                                # calculate a score for each type\n        score = 1.0\n        for p_type in pokemon[1]['types']:                  # calculate type score against each type\n            score *= atk_x_def.loc[type_, p_type]           # multiply the scores because types can cancel each out\n        scores.append(score)\n\n    total_score = len(type_names)**2/sum(scores) # sum because defenses against multiple types, divides total type to reverse from lowest good to highest good\n    defer.append((pokemon[1]['name'], total_score) )\n\nTo see which Pokemon had the highest score, I plotted the top 15 scores of each type on a horizontal bar chart, with the topmost being considered the best.\n\n# Sort the data and divide them for plotting\natker_sort = sorted(atker, key=lambda x: x[1], reverse=True)\natker_names, atk_scores = zip(*atker_sort[:50][::-1])\n\ndefer_sort = sorted(defer, key=lambda x: x[1], reverse=True)\ndefer_names, def_scores = zip(*defer_sort[:50][::-1])\n\n# create the bar plots \nfig, axs = plt.subplots(1, 2, figsize=(15, 10)) \nfig.suptitle('Top 50 Pokemon Type Scores', fontsize=16)\n\naxs[0].barh(atker_names, atk_scores, color='blue')\naxs[0].set_title('Attackers')\n\naxs[1].barh(defer_names, def_scores, color='green')\naxs[1].set_title('Defenders')\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\na = pd.Series([x[1] for x in atker])\nprint(a.unique())\na.describe()\n\n[20.5 23.  22.5 19.  20.  24.  21.  22.  21.5 23.5]\n\n\ncount    1302.000000\nmean       21.952381\nstd         1.320054\nmin        19.000000\n25%        21.000000\n50%        22.500000\n75%        23.000000\nmax        24.000000\ndtype: float64\n\n\n\nd = pd.Series([x[1] for x in defer])\nprint(d.unique())\nd.describe()\n\n[19.82022472 21.         20.51162791 19.6        17.64       20.04545455\n 21.51219512 20.75294118 22.05       21.25301205 15.75       19.17391304\n 16.18348624 23.21052632 18.56842105 16.33333333 18.375      20.27586207\n 16.96153846 18.18556701 22.61538462 18.96774194 21.77777778 17.46534653\n 23.52       18.         16.64150943 26.72727273 23.83783784 27.13846154\n 18.76595745 17.29411765 22.90909091 24.5        25.2        19.38461538\n 25.56521739 15.20689655 17.81818182 16.8        16.03636364]\n\n\ncount    1302.000000\nmean       20.211193\nstd         1.848205\nmin        15.206897\n25%        19.173913\n50%        20.275862\n75%        21.000000\nmax        27.138462\ndtype: float64\n\n\nSimply observing, we can see that there is little no to no variation between the scores of the top 50 scoring attackers or defender, albeit defenders did have more variation. Looking at the attacker graph, the graph forms what almost is a straight line. The defenders, on the other hand, have a more diagonal line, but again, there’s not enough of a difference between any of the defenders to be able to point to a singular Pokemon that can be crowned as the best defender. As there is very little variation in the top scorers in either attacker or defender, it is reasonable to draw the conclusion that there is no real difference between any of the top scorers. The ones shown on the graph will be the ones most effective from a general type effectiveness perspective, though not omniscient, and will be good choices on any team. But, to reiterate, since there is no large or noticeable difference, there is no single Pokemon that will trump the rest as an attacker or a defender.\n\n\n\nWhen I think of analyzing a Pokémon based on its base stats, these are the approaches I think of: - Total Attack Power: Summing up the Attack stat, Special Attack stat, or both provides an overall measure of offensive capability. Pokémon with high combined Attack stats would excel in dealing damage, so that the opponent has less turns to act before they are killed. - Total Defense: Summing up the Defense stat and Special Defense stat gives you an idea of how well a Pokémon can withstand attacks. Pokémon with high combined Defense stats are sturdy and can endure hits effectively, lasting longer in battle. - Attack + Defense Balance: Calculating the sum between Attack and Defense (Attack + Defense) provides insight into offensive versus defensive tendencies. Some Pokémon have high Attack but low Defense, while others have the opposite. Having a balance of these two stats can show you how well rounded a Pokemon is, showing\n\n# Calculate the combined attack, defense, combined attack & defense, and total stats for each Pokemon\ncmb_atk_raw = poke_df['attack'] + poke_df['special-attack']\ncmb_atk = zip(poke_df['name'], cmb_atk_raw)\natk_stat = sorted(cmb_atk, key=lambda x: x[1], reverse=True)\natk_names, atk_vals = zip(*atk_stat[:20][::-1])\n\ncmb_def_raw = poke_df['defense'] + poke_df['special-defense']\ncmb_def = zip(poke_df['name'], cmb_def_raw)\ndef_stat = sorted(cmb_def, key=lambda x: x[1], reverse=True)\ndef_names, def_vals = zip(*def_stat[:20][::-1])\n\ncmb_atkdef = cmb_atk_raw + cmb_def_raw\ncmb_atkdef = zip(poke_df['name'], cmb_atkdef)\ncmb_stat = sorted(cmb_atkdef, key=lambda x: x[1], reverse=True)\ncmb_names, cmb_vals = zip(*cmb_stat[:20][::-1])\n\n\n# create the bar plots \nfig, axs = plt.subplots(1, 3, figsize=(15, 5)) \nfig.suptitle('Top 20 Pokemon by Base Stats', fontsize=16)\n\naxs[0].barh(atk_names, atk_vals, color='blue')\naxs[0].set_title('Attackers')\n\naxs[1].barh(def_names, def_vals, color='green')\naxs[1].set_title('Defenders')\n\naxs[2].barh(cmb_names, cmb_vals, color='red')\naxs[2].set_title('Attackers + Defenders')\n\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nOn these graphs, the scores of each Pokemon entry is calculated on purely numerical instance. As explained prior to the graph, the scores are derived simply by adding the base stats of the particular stat, either attack and special attack or defense and special defense. On the attacker side, we can see that Deoxys-Attack trumps as the Pokemon with the highest combined attack and special attack base stats. But looking further down the graph, we can see Rayquaza-Mega in close second, virtually with the same score. The rest of the top 20 attackers are close on their heels as well, ranging from roughly 295 to 320. On the defender side, with a little more disparity, we see Eternatus-Eternamax leading the pack with a sizeable lead with a combined defense and special defense score of over 500. The Pokemon Shuckle comes in second with more of a difference between the first and second defenders than the top two attackers. The scores of the remaining top 20 defenders drops off steeply into a plateau of scores averaging at about 300. The graph to the far right depicts the Pokemon with the highest combined score of attack, special attack, defense, and special defense. In other words, it could be viewed as a depiction of the previous two graphs combined. Eternatus-Eternamax remains at the top, which make sense given it’s dominance over the defender category. The remainder of the top 20 trickles off slowly.\n\n\n\nThe two previous graphs separated two key components of the way Pokemon fight. Both base stats and types determine damage multipliers of the different moves that Pokemon use in battle in order to eliminate the other trainer, but just as each is important, it would not do to not consider the other. Both are the same side of the coin, as both are damage multipliers. Thus, we need to construct a graph that would consider both components, or in other words, we need to combine the two previous graphs. Additionally, since we will be investigating a new relationship via this new graph, it is important to keep in mind that data may or may not be the same as in the previous graphs as new values will be calculated and added to the mix. Both type effectiveness and base stats are found to be multiplier of the damage that can be dealt, therefore it is viable to say that the product of the two multipliers is a fair value to be used to gauge the effectiveness of a Pokemon’s attack or defense stats in consideration to both of these variables. The graphs below display the top 20 scorers using the reasoning as mentioned.\n\n# Calculate the attack, defense, and combined attack & defense scores scaled with type\na_type_score = []\nfor pokemon, scale in atker:\n    for pokemon2, score in zip(poke_df['name'], cmb_atk_raw):\n        if pokemon == pokemon2:\n            a_type_score.append((pokemon, scale * score))\n\nd_type_score = []\nfor pokemon, scale in defer:\n    for pokemon2, score in zip(poke_df['name'], cmb_def_raw):\n        if pokemon == pokemon2:\n            d_type_score.append((pokemon, scale * score))\n\nc_type_score = []\nfor pokemon, score_a in a_type_score:\n    for pokemon2, score_d in d_type_score:\n        if pokemon == pokemon2:\n            c_type_score.append((pokemon, score_a + score_d))\n\n# sort the scores\na_type_score = sorted(a_type_score, key=lambda x: x[1], reverse=True)\nd_type_score = sorted(d_type_score, key=lambda x: x[1], reverse=True)\nc_type_score = sorted(c_type_score, key=lambda x: x[1], reverse=True)\n\n# separate names and scores\na_type_names, a_type_scores = zip(*a_type_score[:20][::-1])\nd_type_names, d_type_scores = zip(*d_type_score[:20][::-1])\nc_type_names, c_type_scores = zip(*c_type_score[:20][::-1])\n\n# create the bar plots\nfig, axs = plt.subplots(1, 3, figsize=(15, 5))\nfig.suptitle('Top 20 Pokemon by Type Scaled Score', fontsize=16)\n\n# Plot 1: Bar plot of Attackers\naxs[0].barh(a_type_names, a_type_scores, color='blue')\naxs[0].set_title('Attackers')\n\n# Plot 2: Bar plot of Defenders\naxs[1].barh(d_type_names, d_type_scores, color='green')\naxs[1].set_title('Defenders')\n\n# Plot 3: Bar plot of Combined Attackers & Defenders\naxs[2].barh(c_type_names, c_type_scores, color='red')\naxs[2].set_title('Attackers + Defenders')\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\nIn comparison to the previous graphs, not much has changed in terms of shape. The top attacker graphs retains the regular shape, the top defender graph retains the 2 outliers, and the overall graph retains its singular outlier. That is not to say, however, that nothing has changed across the graphs. New Pokemon have changed the rankings of the top attacking and defending scoring Pokemon, however, there isn’t a significant difference in the graph in comparison to the pure base stats graph.\n\n\n\n\nInterestingly, if we look at the base stat graph above, not as many top defenders appear in the top 20 scorers in comparison to the top 20 attackers. It is also of note that the top defenders match the attackers in the top scores, save for the extreme outliers in the defense category. The top 20 defenders, not including the top 2 outliers, range from 290 to 330, while the top 20 attackers range from 340 to 295. It’s a decently even range between the two. However, as mentioned earlier, the top 20 attackers appear more frequently on the top 20 overall attack+defense than the top 20 defenders. In fact, only 5 of 20 top defenders appear in the top 20 overall, whereas 10 of the top 20 attackers are included in the top 20 overall scorers. This loosely implies 2 things: One, that the top defenders are more commonly specialized in just defense since they don’t appear in the top 20 overall scorers. Two, the contrapositive of the previous statement, that the top 20 attackers are more balanced than their top 20 defender counterparts. 10 out of 20 of the top 20 attackers appear in the top 20 overall, whereas only half of that, 5 out of 20 of the top 20 defenders appear in the top overall 20. This would imply that the top attackers more often have a sizeable defense stat to keep them in the overall top ranks whereas top defenders cannot say the same in reverse. However, as mentioned earlier, this is only loosely implied. This hypothesis was only drawn in analysis of the current displayed 20 units of data per category, and more specific data comparison, say between the ratio of attack and defense in the top attackers and defenders, would have to be conducted to be able to solidly say that top attackers are more balanced than top defenders.\nIn addition, I would like to point out my calculations for determining type score is a bit wonky, because in hindsight it would have been easier to determine the effectiveness of types by finding the average, because average a more proportional operation compared to just simply adding. For that reason, I believe that is why the results based just off of type score had such a small range and had little to none variation. For further analysis I would probably choose to do it with an average if I were to use the metric of score typing again.\nI would also like to highlight the skewness and the distribution have multiple peaks. In the data there are definitely multiple groups, as not only were there normal Pokemon, there were also legendary Pokemon, which are intentionally made by the Pokemon company to be stronger due to story reason, but there are also a type of Pokemon I like to call gimmicks (because its basically the same thing under different names) which are also made strong due to the power of friendship. For that reason I would think that to make the analysis better in the future, it would be best to separate the groups from the normal set of Pokemon and conduct an analysis on those separately.\n\n\nTo answer the initial questions that I started, according to the data, there is not outstanding type matchup for Pokemon. In terms of stats, Eternatus-Eternamax seems to be the strongest in both pure stats and with the type score modifier for both overall and defensive, but in terms of pure total attack power, Rayquaza-Mega comes out on top. The lack of an outstanding type matchup for Pokemon makes sense in this data analysis because it would cause gameplay to become unbalanced. Say, for example, your favorite MMORPG game had an overpowered weapon that was capable of destroying everything and anything. All the players would flock to using that weapon and discard all other available weapons in favor for it. The same applies here. The Pokemon franchise prides itself upon its variety of different Pokemon and type-matchup dependent battles. To allow for one type to have a clear advantage would be akin to destroying the mechanics of the game. However, you may find yourself wondering why some Pokemon are so much better than others at all. This is because the Pokemon with higher stats are often legendary or mythical Pokemon, or locked behind some form of story in the game. These Pokemon are the challenge to the player or one of the final bosses, and are thus made intentionally difficult to fight, thus still preserving the reasoning from before.\n\n\n\nEternatus-Eternamax\n\n\n\n\n\nThere are, however, limitations to the comparisons made in this data. Even with set stats, there are many varying factors that all contribute in deciding the victor in a Pokemon battle. It’s near impossible to conclude the winner of a battle just from conclusions driven from hard numerical data, as for example, Pokemon may learn moves of a different type than the Pokemon’s base type, or the level of the Pokemon can boost its stats to that of a level where it can win against a different Pokemon it would normally be at a disadvantage against. Even as we’re talking about predetermined stats, there are abilities or items that Pokemon have that can drastically alter it’s abilities or stats unexpectedly. Professional pokemon players have pulled off huge upstart wins with strategies utilizing these miscellaneous abilities and gimmicks, so it’s not to say this data is the end all be all."
  },
  {
    "objectID": "posts/pokemon_analysis.html#introduction",
    "href": "posts/pokemon_analysis.html#introduction",
    "title": "PokéMetrics: Analyzing Stats and Type Effectiveness",
    "section": "",
    "text": "The Pokemon games are centered around battling others with a team of “pocket monsters,” hence the name of the franchise. With a predetermined set of stats and moves for each of their monster partners, players direct their Pokemon in battle and struggle against other Pokemon trainers to make their way to becoming the champion of the Pokemon world. These stats and decisions ultimately become the deciding factor in who emerges victorious. Thus, it is important for players to understand the stats and inner mechanics of the game. However, the game is a gem of childhood for many, and as children, many had simply played the game without paying much attention to stats and numbers. Of course, the game is designed well and can be played as such, but having played the game in that manner, I struggled. My Pokemon were okay, but were never strong enough for my liking. Of course, having played for so long, I eventually figured out through trial and error which Pokemon were stronger than others, but playing more and more, I find that I still struggle with picking better Pokemon to use.\n\n\nBut now, equipped with time and data, I wanted to take the opportunity to do a data-driven approach towards analyzing the differences in strength between Pokémon through comparing their base stats. I’ve never done an in-depth analysis before, as I simply have just played the game and choosing Pokemon that I liked and thought would do the job. Just last week I was casually playing, but my pokemon kept dying on me right next to the entrance of the next town.\n\n\n\nFor this project, I will be using PokeAPI, an API linked to multiple databases detailing everything about the Pokémon main game series. I will be specifically be using data from these databases: | Dataset | Description | Link | |———|—————————————————————————————————–|————————————————| | Pokemon | Database of all pokemon that exist in the game, as well as their stats | API Docs | | Types | Database of the pokemon types, and anything that relates to them (type effectiveness, Pokemon, etc) | API Docs |\n\n\n\n\nWhich type combination are good to have?\nWhich Pokemon have the best stats?\n\nWhat is the best Pokemon to carry on you when running into random Pokemon and enemy trainers?"
  },
  {
    "objectID": "posts/pokemon_analysis.html#methods",
    "href": "posts/pokemon_analysis.html#methods",
    "title": "PokéMetrics: Analyzing Stats and Type Effectiveness",
    "section": "",
    "text": "The following libraries that this project uses. If you are accessing this project through the binder, they should be already installed, otherwise you should run the following cell.\n\nimport pandas as pd\nimport json\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport requests\n\n\n\n\nBecause I am using an API designed to just give you the complete data about specific things in pokemon, I have to call the API multiple times: first to get the list of items, and then X amount of times to get each specific record/row. Once I get each record, I store it in their respective dataframe: poke_df for pokemon and type_df for types.\n\n# Function to retrieve data from the API\ndef retrieve_data(url):\n    # Getting the list of all Pokemon\n    response = requests.get(url)\n    url_list = response.json()['results']\n\n    # Getting the data for each item\n    details = []\n    for url in url_list:\n        response = requests.get(url['url'])\n        details.append(response.json())\n\n    # Converting data to DataFrame\n    return pd.DataFrame(details)\n\n\n# Getting the list of all Pokemon \nplist_url = \"https://pokeapi.co/api/v2/pokemon?limit=1302&offset=0\"\npoke_df = retrieve_data(plist_url)\n\n# Getting the list of all Pokemon types\ntlist_url = \"https://pokeapi.co/api/v2/type?limit=21&offset=0\"\ntype_df = retrieve_data(tlist_url)\n\n\"\"\"\n# Saving the data to a csv file (for cache reasons)\npoke_df.to_json('data/pokemon_data.json', orient='records', lines=True)\ntype_df.to_json('data/type_data.json', orient='records', lines=True)\n\"\"\"\n\n\"\\n# Saving the data to a csv file (for cache reasons)\\npoke_df.to_json('data/pokemon_data.json', orient='records', lines=True)\\ntype_df.to_json('data/type_data.json', orient='records', lines=True)\\n\"\n\n\nAt the end of the previous block, I previously downloaded the data frames I fetched (code is in comments). This is so in the future if the database is modified, someone else running this project can see what I got now. In order to run using that data, you can uncomment and run the following block.\n\n\"\"\"\n# Loading the data from the csv file\npoke_df = pd.read_json('data/pokemon_data.json', orient='records', lines=True)\ntype_df = pd.read_json('data/type_data.json', orient='records', lines=True)\n\"\"\"\n\n\"\\n# Loading the data from the csv file\\npoke_df = pd.read_json('data/pokemon_data.json', orient='records', lines=True)\\ntype_df = pd.read_json('data/type_data.json', orient='records', lines=True)\\n\"\n\n\n\n\n\nOnce you download the data, it’s a good idea to check what the data you are working with looks like. I do so by using .head().\n\npoke_df.head()\n\n\n\n\n\n\n\n\nabilities\nbase_experience\ncries\nforms\ngame_indices\nheight\nheld_items\nid\nis_default\nlocation_area_encounters\nmoves\nname\norder\npast_abilities\npast_types\nspecies\nsprites\nstats\ntypes\nweight\n\n\n\n\n0\n[{'ability': {'name': 'overgrow', 'url': 'http...\n64.0\n{'latest': 'https://raw.githubusercontent.com/...\n[{'name': 'bulbasaur', 'url': 'https://pokeapi...\n[{'game_index': 153, 'version': {'name': 'red'...\n7\n[]\n1\nTrue\nhttps://pokeapi.co/api/v2/pokemon/1/encounters\n[{'move': {'name': 'razor-wind', 'url': 'https...\nbulbasaur\n1\n[]\n[]\n{'name': 'bulbasaur', 'url': 'https://pokeapi....\n{'back_default': 'https://raw.githubuserconten...\n[{'base_stat': 45, 'effort': 0, 'stat': {'name...\n[{'slot': 1, 'type': {'name': 'grass', 'url': ...\n69\n\n\n1\n[{'ability': {'name': 'overgrow', 'url': 'http...\n142.0\n{'latest': 'https://raw.githubusercontent.com/...\n[{'name': 'ivysaur', 'url': 'https://pokeapi.c...\n[{'game_index': 9, 'version': {'name': 'red', ...\n10\n[]\n2\nTrue\nhttps://pokeapi.co/api/v2/pokemon/2/encounters\n[{'move': {'name': 'swords-dance', 'url': 'htt...\nivysaur\n2\n[]\n[]\n{'name': 'ivysaur', 'url': 'https://pokeapi.co...\n{'back_default': 'https://raw.githubuserconten...\n[{'base_stat': 60, 'effort': 0, 'stat': {'name...\n[{'slot': 1, 'type': {'name': 'grass', 'url': ...\n130\n\n\n2\n[{'ability': {'name': 'overgrow', 'url': 'http...\n263.0\n{'latest': 'https://raw.githubusercontent.com/...\n[{'name': 'venusaur', 'url': 'https://pokeapi....\n[{'game_index': 154, 'version': {'name': 'red'...\n20\n[]\n3\nTrue\nhttps://pokeapi.co/api/v2/pokemon/3/encounters\n[{'move': {'name': 'swords-dance', 'url': 'htt...\nvenusaur\n3\n[]\n[]\n{'name': 'venusaur', 'url': 'https://pokeapi.c...\n{'back_default': 'https://raw.githubuserconten...\n[{'base_stat': 80, 'effort': 0, 'stat': {'name...\n[{'slot': 1, 'type': {'name': 'grass', 'url': ...\n1000\n\n\n3\n[{'ability': {'name': 'blaze', 'url': 'https:/...\n62.0\n{'latest': 'https://raw.githubusercontent.com/...\n[{'name': 'charmander', 'url': 'https://pokeap...\n[{'game_index': 176, 'version': {'name': 'red'...\n6\n[]\n4\nTrue\nhttps://pokeapi.co/api/v2/pokemon/4/encounters\n[{'move': {'name': 'mega-punch', 'url': 'https...\ncharmander\n5\n[]\n[]\n{'name': 'charmander', 'url': 'https://pokeapi...\n{'back_default': 'https://raw.githubuserconten...\n[{'base_stat': 39, 'effort': 0, 'stat': {'name...\n[{'slot': 1, 'type': {'name': 'fire', 'url': '...\n85\n\n\n4\n[{'ability': {'name': 'blaze', 'url': 'https:/...\n142.0\n{'latest': 'https://raw.githubusercontent.com/...\n[{'name': 'charmeleon', 'url': 'https://pokeap...\n[{'game_index': 178, 'version': {'name': 'red'...\n11\n[]\n5\nTrue\nhttps://pokeapi.co/api/v2/pokemon/5/encounters\n[{'move': {'name': 'mega-punch', 'url': 'https...\ncharmeleon\n6\n[]\n[]\n{'name': 'charmeleon', 'url': 'https://pokeapi...\n{'back_default': 'https://raw.githubuserconten...\n[{'base_stat': 58, 'effort': 0, 'stat': {'name...\n[{'slot': 1, 'type': {'name': 'fire', 'url': '...\n190\n\n\n\n\n\n\n\n\ntype_df.head()\n\n\n\n\n\n\n\n\ndamage_relations\ngame_indices\ngeneration\nid\nmove_damage_class\nmoves\nname\nnames\npast_damage_relations\npokemon\n\n\n\n\n0\n{'double_damage_from': [{'name': 'fighting', '...\n[{'game_index': 0, 'generation': {'name': 'gen...\n{'name': 'generation-i', 'url': 'https://pokea...\n1\n{'name': 'physical', 'url': 'https://pokeapi.c...\n[{'name': 'pound', 'url': 'https://pokeapi.co/...\nnormal\n[{'language': {'name': 'ja-Hrkt', 'url': 'http...\n[]\n[{'pokemon': {'name': 'pidgey', 'url': 'https:...\n\n\n1\n{'double_damage_from': [{'name': 'flying', 'ur...\n[{'game_index': 1, 'generation': {'name': 'gen...\n{'name': 'generation-i', 'url': 'https://pokea...\n2\n{'name': 'physical', 'url': 'https://pokeapi.c...\n[{'name': 'karate-chop', 'url': 'https://pokea...\nfighting\n[{'language': {'name': 'ja-Hrkt', 'url': 'http...\n[]\n[{'pokemon': {'name': 'mankey', 'url': 'https:...\n\n\n2\n{'double_damage_from': [{'name': 'rock', 'url'...\n[{'game_index': 2, 'generation': {'name': 'gen...\n{'name': 'generation-i', 'url': 'https://pokea...\n3\n{'name': 'physical', 'url': 'https://pokeapi.c...\n[{'name': 'gust', 'url': 'https://pokeapi.co/a...\nflying\n[{'language': {'name': 'ja-Hrkt', 'url': 'http...\n[]\n[{'pokemon': {'name': 'charizard', 'url': 'htt...\n\n\n3\n{'double_damage_from': [{'name': 'ground', 'ur...\n[{'game_index': 3, 'generation': {'name': 'gen...\n{'name': 'generation-i', 'url': 'https://pokea...\n4\n{'name': 'physical', 'url': 'https://pokeapi.c...\n[{'name': 'poison-sting', 'url': 'https://poke...\npoison\n[{'language': {'name': 'ja-Hrkt', 'url': 'http...\n[{'damage_relations': {'double_damage_from': [...\n[{'pokemon': {'name': 'bulbasaur', 'url': 'htt...\n\n\n4\n{'double_damage_from': [{'name': 'water', 'url...\n[{'game_index': 4, 'generation': {'name': 'gen...\n{'name': 'generation-i', 'url': 'https://pokea...\n5\n{'name': 'physical', 'url': 'https://pokeapi.c...\n[{'name': 'sand-attack', 'url': 'https://pokea...\nground\n[{'language': {'name': 'ja-Hrkt', 'url': 'http...\n[]\n[{'pokemon': {'name': 'sandshrew', 'url': 'htt...\n\n\n\n\n\n\n\nWe can see that theres a lot of JSON data in there that isn’t very useful for analysis right off the bat. Because I only want data in specific columns (‘type’ and ‘stats’ in poke_df and ‘damage_relations’ in type_df), I’ll just process the data in those columns.\n\n# Looking at what values in poke_df['types'] look like\npoke_df['types'][0]\n\n[{'slot': 1,\n  'type': {'name': 'grass', 'url': 'https://pokeapi.co/api/v2/type/12/'}},\n {'slot': 2,\n  'type': {'name': 'poison', 'url': 'https://pokeapi.co/api/v2/type/4/'}}]\n\n\nFor ‘types’ in poke_df, because we are just getting the values of all type.name, we just search for the values in the JSON and save it as a list. I chose not to do it as 2 columns as it would result in null values, which I think would make more work later for me when making data visualizations, so I just replaced the original value with the new list.\n\n# Extra every type name into list for each Pokemon and replace the 'types' column\ntypes_array = []\nfor val in poke_df['types']:\n    types = []\n    for attr in val: \n        types.append(attr['type']['name'])\n    types_array.append(types)\n\npoke_df['types'] = types_array\npoke_df['types'].head()\n\n0    [grass, poison]\n1    [grass, poison]\n2    [grass, poison]\n3             [fire]\n4             [fire]\nName: types, dtype: object\n\n\n\n# Looking at what values in poke_df['stats'] look like\npoke_df['stats'][0]\n\n[{'base_stat': 45,\n  'effort': 0,\n  'stat': {'name': 'hp', 'url': 'https://pokeapi.co/api/v2/stat/1/'}},\n {'base_stat': 49,\n  'effort': 0,\n  'stat': {'name': 'attack', 'url': 'https://pokeapi.co/api/v2/stat/2/'}},\n {'base_stat': 49,\n  'effort': 0,\n  'stat': {'name': 'defense', 'url': 'https://pokeapi.co/api/v2/stat/3/'}},\n {'base_stat': 65,\n  'effort': 1,\n  'stat': {'name': 'special-attack',\n   'url': 'https://pokeapi.co/api/v2/stat/4/'}},\n {'base_stat': 65,\n  'effort': 0,\n  'stat': {'name': 'special-defense',\n   'url': 'https://pokeapi.co/api/v2/stat/5/'}},\n {'base_stat': 45,\n  'effort': 0,\n  'stat': {'name': 'speed', 'url': 'https://pokeapi.co/api/v2/stat/6/'}}]\n\n\nFor ‘stats’ in poke_df, I wanted the name of the stat as well as its value (a int) so I just directly made a dictionary and set the key-value there as normal. Then I collected all the dictionaries into a list, turned the list into a data frame, and merged the new data frame with the original.\n\n# Extract the stat.name and base_stat into a list of dictionaries for each Pokemon\n# Also while having all the stats for a row/Pokemon, calculate the total stats\nstats_df = []\nfor val in poke_df['stats']:\n    stats = {}\n    for attr in val:\n        stats[attr['stat']['name']] = attr['base_stat']\n    stats[\"total\"] = sum(stats.values())\n    stats_df.append(stats)\n \n# Convert stats into a Pandas dataframe and merge with the original df\nstats_df = pd.DataFrame(stats_df)\npoke_df = pd.concat([poke_df, stats_df], axis=1)\npoke_df[['hp', 'attack', 'defense', 'speed', 'special-attack', 'special-defense', 'total']].head()\n\n\n\n\n\n\n\n\nhp\nattack\ndefense\nspeed\nspecial-attack\nspecial-defense\ntotal\n\n\n\n\n0\n45\n49\n49\n45\n65\n65\n318\n\n\n1\n60\n62\n63\n60\n80\n80\n405\n\n\n2\n80\n82\n83\n80\n100\n100\n525\n\n\n3\n39\n52\n43\n65\n60\n50\n309\n\n\n4\n58\n64\n58\n80\n80\n65\n405\n\n\n\n\n\n\n\n\n# looking at what values in type_df['damage_relations'] look like\ntype_df['damage_relations'][0]\n\n{'double_damage_from': [{'name': 'fighting',\n   'url': 'https://pokeapi.co/api/v2/type/2/'}],\n 'double_damage_to': [],\n 'half_damage_from': [],\n 'half_damage_to': [{'name': 'rock',\n   'url': 'https://pokeapi.co/api/v2/type/6/'},\n  {'name': 'steel', 'url': 'https://pokeapi.co/api/v2/type/9/'}],\n 'no_damage_from': [{'name': 'ghost',\n   'url': 'https://pokeapi.co/api/v2/type/8/'}],\n 'no_damage_to': [{'name': 'ghost',\n   'url': 'https://pokeapi.co/api/v2/type/8/'}]}\n\n\nFor the damage relations in type_df, I wanted to extract out the name of the type of damage and keep it as the column name, and the values in the column to be a list of the corresponding relation, so I first made a dictionary, converted the values into a list, made the key-value pairs. Then I put all the dictionaries into a list, turned it into a data frame and merged it with the original one.\n\n# get type names for set difference for normal damage\ntype_names = type_df['name'].values\n\n# extract each damage relation + data into list of dicts for each type\ndmg_df = [] \nfor val in type_df['damage_relations']:\n    t_looked = []                           # for keeping check which we have looked at \n    \n    # looks at attributes for damage multiplier\n    damage = {}\n    for attr in val:     \n        # extract the type names in damage multiplier data                   \n        type_list = []\n        for type_ in val[attr]:  \n            type_list.append(type_['name'])\n            if attr[-2:] == 'to':\n                t_looked.append(type_['name'])\n                # keep track of which types we have looked at in to \n                # no look at from because we dont need to double count\n\n        damage[attr] = type_list\n    \n    # added attr of normal damage and the values that should be in there\n    damage['normal_damage_to'] = list(set(type_names) - set(t_looked))\n\n    dmg_df.append(damage)\n\n# Convert damage into a Pandas dataframe and merge with the original df\ndmg_df = pd.DataFrame(dmg_df)\ntype_df = pd.concat([type_df, dmg_df], axis=1)\ntype_df[['double_damage_from', 'double_damage_to', 'half_damage_from', 'half_damage_to', 'no_damage_from', 'no_damage_to', 'normal_damage_to']].head()\n        \n\n\n\n\n\n\n\n\ndouble_damage_from\ndouble_damage_to\nhalf_damage_from\nhalf_damage_to\nno_damage_from\nno_damage_to\nnormal_damage_to\n\n\n\n\n0\n[fighting]\n[]\n[]\n[rock, steel]\n[ghost]\n[ghost]\n[poison, fairy, dragon, unknown, water, electr...\n\n\n1\n[flying, psychic, fairy]\n[normal, rock, steel, ice, dark]\n[rock, bug, dark]\n[flying, poison, bug, psychic, fairy]\n[]\n[ghost]\n[electric, shadow, fighting, fire, dragon, gro...\n\n\n2\n[rock, electric, ice]\n[fighting, bug, grass]\n[fighting, bug, grass]\n[rock, steel, electric]\n[ground]\n[]\n[shadow, poison, fairy, normal, dark, psychic,...\n\n\n3\n[ground, psychic]\n[grass, fairy]\n[fighting, poison, bug, grass, fairy]\n[poison, ground, rock, ghost]\n[]\n[steel]\n[electric, shadow, normal, dark, bug, psychic,...\n\n\n4\n[water, grass, ice]\n[poison, rock, steel, fire, electric]\n[poison, rock]\n[bug, grass]\n[electric]\n[flying]\n[shadow, fairy, normal, dark, psychic, ice, dr...\n\n\n\n\n\n\n\n\n\n\nNow that we have process all the necessary data, we can drop all the other columns that are unnecessary.\n\npoke_df = poke_df[['name', 'types', 'hp', 'attack', 'defense', 'speed', 'special-attack', 'special-defense', 'total']]\npoke_df.head()\n\n\n\n\n\n\n\n\nname\ntypes\nhp\nattack\ndefense\nspeed\nspecial-attack\nspecial-defense\ntotal\n\n\n\n\n0\nbulbasaur\n[grass, poison]\n45\n49\n49\n45\n65\n65\n318\n\n\n1\nivysaur\n[grass, poison]\n60\n62\n63\n60\n80\n80\n405\n\n\n2\nvenusaur\n[grass, poison]\n80\n82\n83\n80\n100\n100\n525\n\n\n3\ncharmander\n[fire]\n39\n52\n43\n65\n60\n50\n309\n\n\n4\ncharmeleon\n[fire]\n58\n64\n58\n80\n80\n65\n405\n\n\n\n\n\n\n\n\ntype_df = type_df[['name', 'double_damage_to', 'normal_damage_to', 'half_damage_to', 'no_damage_to']]\ntype_df.head() \n\n\n\n\n\n\n\n\nname\ndouble_damage_to\nnormal_damage_to\nhalf_damage_to\nno_damage_to\n\n\n\n\n0\nnormal\n[]\n[poison, fairy, dragon, unknown, water, electr...\n[rock, steel]\n[ghost]\n\n\n1\nfighting\n[normal, rock, steel, ice, dark]\n[electric, shadow, fighting, fire, dragon, gro...\n[flying, poison, bug, psychic, fairy]\n[ghost]\n\n\n2\nflying\n[fighting, bug, grass]\n[shadow, poison, fairy, normal, dark, psychic,...\n[rock, steel, electric]\n[]\n\n\n3\npoison\n[grass, fairy]\n[electric, shadow, normal, dark, bug, psychic,...\n[poison, ground, rock, ghost]\n[steel]\n\n\n4\nground\n[poison, rock, steel, fire, electric]\n[shadow, fairy, normal, dark, psychic, ice, dr...\n[bug, grass]\n[flying]\n\n\n\n\n\n\n\nAs a precaution, we should check and remove any rows that are missing data (NA, NaN, null).\n\npoke_df.isnull().sum()\n# no need to call dropna() as there are no nulls\n\nname               0\ntypes              0\nhp                 0\nattack             0\ndefense            0\nspeed              0\nspecial-attack     0\nspecial-defense    0\ntotal              0\ndtype: int64\n\n\n\ntype_df.isnull().sum()\n# also no need to call dropna()\n\nname                0\ndouble_damage_to    0\nnormal_damage_to    0\nhalf_damage_to      0\nno_damage_to        0\ndtype: int64\n\n\n\n\n\n\n\nTo get a quick overview of the the data, I ran both .info() and .describe() on the data frames.\n\npoke_df.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 1302 entries, 0 to 1301\nData columns (total 9 columns):\n #   Column           Non-Null Count  Dtype \n---  ------           --------------  ----- \n 0   name             1302 non-null   object\n 1   types            1302 non-null   object\n 2   hp               1302 non-null   int64 \n 3   attack           1302 non-null   int64 \n 4   defense          1302 non-null   int64 \n 5   speed            1302 non-null   int64 \n 6   special-attack   1302 non-null   int64 \n 7   special-defense  1302 non-null   int64 \n 8   total            1302 non-null   int64 \ndtypes: int64(7), object(2)\nmemory usage: 91.7+ KB\n\n\n\npoke_df.describe()\n\n\n\n\n\n\n\n\nhp\nattack\ndefense\nspeed\nspecial-attack\nspecial-defense\ntotal\n\n\n\n\ncount\n1302.000000\n1302.000000\n1302.000000\n1302.000000\n1302.000000\n1302.000000\n1302.000000\n\n\nmean\n71.264977\n81.580645\n75.241935\n71.156682\n73.649002\n72.966974\n445.860215\n\n\nstd\n26.764202\n31.673015\n30.492559\n30.310259\n32.469611\n27.358069\n119.865940\n\n\nmin\n1.000000\n5.000000\n5.000000\n5.000000\n10.000000\n20.000000\n175.000000\n\n\n25%\n54.000000\n58.000000\n53.000000\n48.000000\n50.000000\n52.000000\n335.000000\n\n\n50%\n70.000000\n80.000000\n70.000000\n70.000000\n65.000000\n70.000000\n470.000000\n\n\n75%\n85.000000\n100.000000\n95.000000\n92.000000\n95.000000\n90.000000\n525.000000\n\n\nmax\n255.000000\n190.000000\n250.000000\n200.000000\n194.000000\n250.000000\n1125.000000\n\n\n\n\n\n\n\nLooking at the Pokemon Data, there seems to be outliers towards the maximum, as they seem to have a standard distribution way higher than the rest. This is expected, as I believe that the points at the further end are probably some legendary Pokemon, which tends to be stronger because they tend to represent the “gods” of the Pokemon world.\n\n\n\nIn order to get a more in depth view of Pokemon stats, I decided to draw up all the distribution of each of the individual stats.\n\n# Create 3x3 grid of subplots\nfig, axs = plt.subplots(3, 3, figsize=(15, 15)) \nfig.suptitle('Pokemon Stats Distributions')\n\n# Plot 1: Histogram of HP\naxs[0, 0].hist(poke_df['hp'], color='blue')\naxs[0, 0].set_title('HP Distribution')\naxs[0, 0].set_xlabel('HP')\naxs[0, 0].set_ylabel('Frequency')\n\n# Plot 2: Histogram of Attack\naxs[0, 1].hist(poke_df['attack'], color='green')\naxs[0, 1].set_title('Attack Distribution')\naxs[0, 1].set_xlabel('Attack')\naxs[0, 1].set_ylabel('Frequency')\n\n# Plot 3: Histogram of Defense\naxs[0, 2].hist(poke_df['defense'], color='red')\naxs[0, 2].set_title('Defense Distribution')\naxs[0, 2].set_xlabel('Defense')\naxs[0, 2].set_ylabel('Frequency')\n\n# Plot 4: Histogram of Speed\naxs[1, 0].hist(poke_df['speed'], color='purple')\naxs[1, 0].set_title('Speed Distribution')\naxs[1, 0].set_xlabel('Speed')\naxs[1, 0].set_ylabel('Frequency')\n\n# Plot 5: Histogram of Special Attack\naxs[1, 1].hist(poke_df['special-attack'], color='orange')\naxs[1, 1].set_title('Special Attack Distribution')\naxs[1, 1].set_xlabel('Special Attack')\naxs[1, 1].set_ylabel('Frequency')\n\n# Plot 6: Histogram of Special Defense\naxs[1, 2].hist(poke_df['special-defense'], color='brown')\naxs[1, 2].set_title('Special Defense Distribution')\naxs[1, 2].set_xlabel('Special Defense')\naxs[1, 2].set_ylabel('Frequency')\n\n# Plot 7: Histogram of Total Stats\naxs[2, 1].hist(poke_df['total'], color='black')\naxs[2, 1].set_title('Total Stats Distribution')\naxs[2, 1].set_xlabel('Total Stats')\naxs[2, 1].set_ylabel('Frequency')\n\n# Adjust layout to prevent overlap and show plots\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nAs you can see, a lot of of the stats seem to be skewed a little bit to the left. In addition, there are multiple plots with 2 peaks, suggesting that there are possible 2 subgroups of pokemon in here.\n\n\n\nI decided to make heatmap of the effectiveness of each pokemon to see where possibly there might be a good indicator of which type matchup would be best. In order to make it, I made a n x n data frame based on how much damage an attacking type (row) would do against a defending type(column). As for the value in each cell, I set as the scale that an attack would change based on the type effectiveness that the attacker would deal.\n\n# Initialize an empty DataFrame with attackers as rows and defenders as columns\natk_x_def = pd.DataFrame(0.0, index=type_names, columns=type_names)\n\n# Fill in df based on relations in type_df\nfor row in type_df.iterrows():\n    for col in type_names:        \n        if col in row[1]['double_damage_to']:\n            atk_x_def.loc[row[1]['name'], col] = 2.0\n        elif col in row[1]['half_damage_to']:\n            atk_x_def.loc[row[1]['name'], col] = 0.5\n        elif col in row[1]['no_damage_to']:\n            atk_x_def.loc[row[1]['name'], col] = 0\n        else:\n            atk_x_def.loc[row[1]['name'], col] = 1.0       \n        \n# Display the resulting DataFrame\natk_x_def\n\n\n\n\n\n\n\n\nnormal\nfighting\nflying\npoison\nground\nrock\nbug\nghost\nsteel\nfire\n...\ngrass\nelectric\npsychic\nice\ndragon\ndark\nfairy\nstellar\nunknown\nshadow\n\n\n\n\nnormal\n1.0\n1.0\n1.0\n1.0\n1.0\n0.5\n1.0\n0.0\n0.5\n1.0\n...\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\nfighting\n2.0\n1.0\n0.5\n0.5\n1.0\n2.0\n0.5\n0.0\n2.0\n1.0\n...\n1.0\n1.0\n0.5\n2.0\n1.0\n2.0\n0.5\n1.0\n1.0\n1.0\n\n\nflying\n1.0\n2.0\n1.0\n1.0\n1.0\n0.5\n2.0\n1.0\n0.5\n1.0\n...\n2.0\n0.5\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\npoison\n1.0\n1.0\n1.0\n0.5\n0.5\n0.5\n1.0\n0.5\n0.0\n1.0\n...\n2.0\n1.0\n1.0\n1.0\n1.0\n1.0\n2.0\n1.0\n1.0\n1.0\n\n\nground\n1.0\n1.0\n0.0\n2.0\n1.0\n2.0\n0.5\n1.0\n2.0\n2.0\n...\n0.5\n2.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\nrock\n1.0\n0.5\n2.0\n1.0\n0.5\n1.0\n2.0\n1.0\n0.5\n2.0\n...\n1.0\n1.0\n1.0\n2.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\nbug\n1.0\n0.5\n0.5\n0.5\n1.0\n1.0\n1.0\n0.5\n0.5\n0.5\n...\n2.0\n1.0\n2.0\n1.0\n1.0\n2.0\n0.5\n1.0\n1.0\n1.0\n\n\nghost\n0.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n2.0\n1.0\n1.0\n...\n1.0\n1.0\n2.0\n1.0\n1.0\n0.5\n1.0\n1.0\n1.0\n1.0\n\n\nsteel\n1.0\n1.0\n1.0\n1.0\n1.0\n2.0\n1.0\n1.0\n0.5\n0.5\n...\n1.0\n0.5\n1.0\n2.0\n1.0\n1.0\n2.0\n1.0\n1.0\n1.0\n\n\nfire\n1.0\n1.0\n1.0\n1.0\n1.0\n0.5\n2.0\n1.0\n2.0\n0.5\n...\n2.0\n1.0\n1.0\n2.0\n0.5\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\nwater\n1.0\n1.0\n1.0\n1.0\n2.0\n2.0\n1.0\n1.0\n1.0\n2.0\n...\n0.5\n1.0\n1.0\n1.0\n0.5\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\ngrass\n1.0\n1.0\n0.5\n0.5\n2.0\n2.0\n0.5\n1.0\n0.5\n0.5\n...\n0.5\n1.0\n1.0\n1.0\n0.5\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\nelectric\n1.0\n1.0\n2.0\n1.0\n0.0\n1.0\n1.0\n1.0\n1.0\n1.0\n...\n0.5\n0.5\n1.0\n1.0\n0.5\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\npsychic\n1.0\n2.0\n1.0\n2.0\n1.0\n1.0\n1.0\n1.0\n0.5\n1.0\n...\n1.0\n1.0\n0.5\n1.0\n1.0\n0.0\n1.0\n1.0\n1.0\n1.0\n\n\nice\n1.0\n1.0\n2.0\n1.0\n2.0\n1.0\n1.0\n1.0\n0.5\n0.5\n...\n2.0\n1.0\n1.0\n0.5\n2.0\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\ndragon\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n0.5\n1.0\n...\n1.0\n1.0\n1.0\n1.0\n2.0\n1.0\n0.0\n1.0\n1.0\n1.0\n\n\ndark\n1.0\n0.5\n1.0\n1.0\n1.0\n1.0\n1.0\n2.0\n1.0\n1.0\n...\n1.0\n1.0\n2.0\n1.0\n1.0\n0.5\n0.5\n1.0\n1.0\n1.0\n\n\nfairy\n1.0\n2.0\n1.0\n0.5\n1.0\n1.0\n1.0\n1.0\n0.5\n0.5\n...\n1.0\n1.0\n1.0\n1.0\n2.0\n2.0\n1.0\n1.0\n1.0\n1.0\n\n\nstellar\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n...\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\nunknown\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n...\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\nshadow\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n...\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n1.0\n\n\n\n\n21 rows × 21 columns\n\n\n\nOnce my data frame was made, using the seaborn package, I plotted the heatmap using the coolwarm to show a clear color difference from when it doing more damage verse less, with white being no change.\n\nplt.figure(figsize=(10, 10))\nsns.heatmap(atk_x_def, annot=True, cmap='coolwarm')\nplt.title('Damage Multiplier Heatmap')\nplt.ylabel('Attacker Type')\nplt.xlabel('Defender Type')\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nUsing this graph, it makes it easier to identify the weakness nad strengths of a pokemon, however you can’t really identify any clear patterns as to which is clearly the superior type. (This is relevant)"
  },
  {
    "objectID": "posts/pokemon_analysis.html#analysis-results",
    "href": "posts/pokemon_analysis.html#analysis-results",
    "title": "PokéMetrics: Analyzing Stats and Type Effectiveness",
    "section": "",
    "text": "In order to make analyzing typings easier, I’m going to say that the overall effectiveness score is a sum of all the individual scores for each type. The more effective a type will be, the higher the score. I can think of 2 ways to compute the score.\nThe first way is to measure how effective a Pokemon’s moves would be against any other type. To calculate each individual score, I determined that choosing the more effective type of the Pokemon were against any other type. I decided to find the max because in the games, a Pokemon move can only be one type.\n\n# Score for effectiveness of their attacks\n# Higher score, the better the attack\natker = []\nfor pokemon in poke_df.iterrows():\n    scores = []\n    for type_ in pokemon[1]['types']:                       # calculate a score for each type\n        scores.append(atk_x_def.loc[type_].sum())\n    atker.append((pokemon[1]['name'], max(scores)))         # max because attacks are one type\n\nThe other way is to measure how much damage the Pokemon can resist when they are attacked by a specific type of move. I calculated this using the product of the scores that the attacking type would deal based on the defending Pokemon’s typing, just like in game.\n\n# Score based on the effectiveness of their defenses\n# Lower score, the better the defense\ndefer = []\nfor pokemon in poke_df.iterrows():\n    scores = []\n    for type_ in type_names:                                # calculate a score for each type\n        score = 1.0\n        for p_type in pokemon[1]['types']:                  # calculate type score against each type\n            score *= atk_x_def.loc[type_, p_type]           # multiply the scores because types can cancel each out\n        scores.append(score)\n\n    total_score = len(type_names)**2/sum(scores) # sum because defenses against multiple types, divides total type to reverse from lowest good to highest good\n    defer.append((pokemon[1]['name'], total_score) )\n\nTo see which Pokemon had the highest score, I plotted the top 15 scores of each type on a horizontal bar chart, with the topmost being considered the best.\n\n# Sort the data and divide them for plotting\natker_sort = sorted(atker, key=lambda x: x[1], reverse=True)\natker_names, atk_scores = zip(*atker_sort[:50][::-1])\n\ndefer_sort = sorted(defer, key=lambda x: x[1], reverse=True)\ndefer_names, def_scores = zip(*defer_sort[:50][::-1])\n\n# create the bar plots \nfig, axs = plt.subplots(1, 2, figsize=(15, 10)) \nfig.suptitle('Top 50 Pokemon Type Scores', fontsize=16)\n\naxs[0].barh(atker_names, atk_scores, color='blue')\naxs[0].set_title('Attackers')\n\naxs[1].barh(defer_names, def_scores, color='green')\naxs[1].set_title('Defenders')\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\na = pd.Series([x[1] for x in atker])\nprint(a.unique())\na.describe()\n\n[20.5 23.  22.5 19.  20.  24.  21.  22.  21.5 23.5]\n\n\ncount    1302.000000\nmean       21.952381\nstd         1.320054\nmin        19.000000\n25%        21.000000\n50%        22.500000\n75%        23.000000\nmax        24.000000\ndtype: float64\n\n\n\nd = pd.Series([x[1] for x in defer])\nprint(d.unique())\nd.describe()\n\n[19.82022472 21.         20.51162791 19.6        17.64       20.04545455\n 21.51219512 20.75294118 22.05       21.25301205 15.75       19.17391304\n 16.18348624 23.21052632 18.56842105 16.33333333 18.375      20.27586207\n 16.96153846 18.18556701 22.61538462 18.96774194 21.77777778 17.46534653\n 23.52       18.         16.64150943 26.72727273 23.83783784 27.13846154\n 18.76595745 17.29411765 22.90909091 24.5        25.2        19.38461538\n 25.56521739 15.20689655 17.81818182 16.8        16.03636364]\n\n\ncount    1302.000000\nmean       20.211193\nstd         1.848205\nmin        15.206897\n25%        19.173913\n50%        20.275862\n75%        21.000000\nmax        27.138462\ndtype: float64\n\n\nSimply observing, we can see that there is little no to no variation between the scores of the top 50 scoring attackers or defender, albeit defenders did have more variation. Looking at the attacker graph, the graph forms what almost is a straight line. The defenders, on the other hand, have a more diagonal line, but again, there’s not enough of a difference between any of the defenders to be able to point to a singular Pokemon that can be crowned as the best defender. As there is very little variation in the top scorers in either attacker or defender, it is reasonable to draw the conclusion that there is no real difference between any of the top scorers. The ones shown on the graph will be the ones most effective from a general type effectiveness perspective, though not omniscient, and will be good choices on any team. But, to reiterate, since there is no large or noticeable difference, there is no single Pokemon that will trump the rest as an attacker or a defender.\n\n\n\nWhen I think of analyzing a Pokémon based on its base stats, these are the approaches I think of: - Total Attack Power: Summing up the Attack stat, Special Attack stat, or both provides an overall measure of offensive capability. Pokémon with high combined Attack stats would excel in dealing damage, so that the opponent has less turns to act before they are killed. - Total Defense: Summing up the Defense stat and Special Defense stat gives you an idea of how well a Pokémon can withstand attacks. Pokémon with high combined Defense stats are sturdy and can endure hits effectively, lasting longer in battle. - Attack + Defense Balance: Calculating the sum between Attack and Defense (Attack + Defense) provides insight into offensive versus defensive tendencies. Some Pokémon have high Attack but low Defense, while others have the opposite. Having a balance of these two stats can show you how well rounded a Pokemon is, showing\n\n# Calculate the combined attack, defense, combined attack & defense, and total stats for each Pokemon\ncmb_atk_raw = poke_df['attack'] + poke_df['special-attack']\ncmb_atk = zip(poke_df['name'], cmb_atk_raw)\natk_stat = sorted(cmb_atk, key=lambda x: x[1], reverse=True)\natk_names, atk_vals = zip(*atk_stat[:20][::-1])\n\ncmb_def_raw = poke_df['defense'] + poke_df['special-defense']\ncmb_def = zip(poke_df['name'], cmb_def_raw)\ndef_stat = sorted(cmb_def, key=lambda x: x[1], reverse=True)\ndef_names, def_vals = zip(*def_stat[:20][::-1])\n\ncmb_atkdef = cmb_atk_raw + cmb_def_raw\ncmb_atkdef = zip(poke_df['name'], cmb_atkdef)\ncmb_stat = sorted(cmb_atkdef, key=lambda x: x[1], reverse=True)\ncmb_names, cmb_vals = zip(*cmb_stat[:20][::-1])\n\n\n# create the bar plots \nfig, axs = plt.subplots(1, 3, figsize=(15, 5)) \nfig.suptitle('Top 20 Pokemon by Base Stats', fontsize=16)\n\naxs[0].barh(atk_names, atk_vals, color='blue')\naxs[0].set_title('Attackers')\n\naxs[1].barh(def_names, def_vals, color='green')\naxs[1].set_title('Defenders')\n\naxs[2].barh(cmb_names, cmb_vals, color='red')\naxs[2].set_title('Attackers + Defenders')\n\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\nOn these graphs, the scores of each Pokemon entry is calculated on purely numerical instance. As explained prior to the graph, the scores are derived simply by adding the base stats of the particular stat, either attack and special attack or defense and special defense. On the attacker side, we can see that Deoxys-Attack trumps as the Pokemon with the highest combined attack and special attack base stats. But looking further down the graph, we can see Rayquaza-Mega in close second, virtually with the same score. The rest of the top 20 attackers are close on their heels as well, ranging from roughly 295 to 320. On the defender side, with a little more disparity, we see Eternatus-Eternamax leading the pack with a sizeable lead with a combined defense and special defense score of over 500. The Pokemon Shuckle comes in second with more of a difference between the first and second defenders than the top two attackers. The scores of the remaining top 20 defenders drops off steeply into a plateau of scores averaging at about 300. The graph to the far right depicts the Pokemon with the highest combined score of attack, special attack, defense, and special defense. In other words, it could be viewed as a depiction of the previous two graphs combined. Eternatus-Eternamax remains at the top, which make sense given it’s dominance over the defender category. The remainder of the top 20 trickles off slowly.\n\n\n\nThe two previous graphs separated two key components of the way Pokemon fight. Both base stats and types determine damage multipliers of the different moves that Pokemon use in battle in order to eliminate the other trainer, but just as each is important, it would not do to not consider the other. Both are the same side of the coin, as both are damage multipliers. Thus, we need to construct a graph that would consider both components, or in other words, we need to combine the two previous graphs. Additionally, since we will be investigating a new relationship via this new graph, it is important to keep in mind that data may or may not be the same as in the previous graphs as new values will be calculated and added to the mix. Both type effectiveness and base stats are found to be multiplier of the damage that can be dealt, therefore it is viable to say that the product of the two multipliers is a fair value to be used to gauge the effectiveness of a Pokemon’s attack or defense stats in consideration to both of these variables. The graphs below display the top 20 scorers using the reasoning as mentioned.\n\n# Calculate the attack, defense, and combined attack & defense scores scaled with type\na_type_score = []\nfor pokemon, scale in atker:\n    for pokemon2, score in zip(poke_df['name'], cmb_atk_raw):\n        if pokemon == pokemon2:\n            a_type_score.append((pokemon, scale * score))\n\nd_type_score = []\nfor pokemon, scale in defer:\n    for pokemon2, score in zip(poke_df['name'], cmb_def_raw):\n        if pokemon == pokemon2:\n            d_type_score.append((pokemon, scale * score))\n\nc_type_score = []\nfor pokemon, score_a in a_type_score:\n    for pokemon2, score_d in d_type_score:\n        if pokemon == pokemon2:\n            c_type_score.append((pokemon, score_a + score_d))\n\n# sort the scores\na_type_score = sorted(a_type_score, key=lambda x: x[1], reverse=True)\nd_type_score = sorted(d_type_score, key=lambda x: x[1], reverse=True)\nc_type_score = sorted(c_type_score, key=lambda x: x[1], reverse=True)\n\n# separate names and scores\na_type_names, a_type_scores = zip(*a_type_score[:20][::-1])\nd_type_names, d_type_scores = zip(*d_type_score[:20][::-1])\nc_type_names, c_type_scores = zip(*c_type_score[:20][::-1])\n\n# create the bar plots\nfig, axs = plt.subplots(1, 3, figsize=(15, 5))\nfig.suptitle('Top 20 Pokemon by Type Scaled Score', fontsize=16)\n\n# Plot 1: Bar plot of Attackers\naxs[0].barh(a_type_names, a_type_scores, color='blue')\naxs[0].set_title('Attackers')\n\n# Plot 2: Bar plot of Defenders\naxs[1].barh(d_type_names, d_type_scores, color='green')\naxs[1].set_title('Defenders')\n\n# Plot 3: Bar plot of Combined Attackers & Defenders\naxs[2].barh(c_type_names, c_type_scores, color='red')\naxs[2].set_title('Attackers + Defenders')\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\nIn comparison to the previous graphs, not much has changed in terms of shape. The top attacker graphs retains the regular shape, the top defender graph retains the 2 outliers, and the overall graph retains its singular outlier. That is not to say, however, that nothing has changed across the graphs. New Pokemon have changed the rankings of the top attacking and defending scoring Pokemon, however, there isn’t a significant difference in the graph in comparison to the pure base stats graph."
  },
  {
    "objectID": "posts/pokemon_analysis.html#discussion",
    "href": "posts/pokemon_analysis.html#discussion",
    "title": "PokéMetrics: Analyzing Stats and Type Effectiveness",
    "section": "",
    "text": "Interestingly, if we look at the base stat graph above, not as many top defenders appear in the top 20 scorers in comparison to the top 20 attackers. It is also of note that the top defenders match the attackers in the top scores, save for the extreme outliers in the defense category. The top 20 defenders, not including the top 2 outliers, range from 290 to 330, while the top 20 attackers range from 340 to 295. It’s a decently even range between the two. However, as mentioned earlier, the top 20 attackers appear more frequently on the top 20 overall attack+defense than the top 20 defenders. In fact, only 5 of 20 top defenders appear in the top 20 overall, whereas 10 of the top 20 attackers are included in the top 20 overall scorers. This loosely implies 2 things: One, that the top defenders are more commonly specialized in just defense since they don’t appear in the top 20 overall scorers. Two, the contrapositive of the previous statement, that the top 20 attackers are more balanced than their top 20 defender counterparts. 10 out of 20 of the top 20 attackers appear in the top 20 overall, whereas only half of that, 5 out of 20 of the top 20 defenders appear in the top overall 20. This would imply that the top attackers more often have a sizeable defense stat to keep them in the overall top ranks whereas top defenders cannot say the same in reverse. However, as mentioned earlier, this is only loosely implied. This hypothesis was only drawn in analysis of the current displayed 20 units of data per category, and more specific data comparison, say between the ratio of attack and defense in the top attackers and defenders, would have to be conducted to be able to solidly say that top attackers are more balanced than top defenders.\nIn addition, I would like to point out my calculations for determining type score is a bit wonky, because in hindsight it would have been easier to determine the effectiveness of types by finding the average, because average a more proportional operation compared to just simply adding. For that reason, I believe that is why the results based just off of type score had such a small range and had little to none variation. For further analysis I would probably choose to do it with an average if I were to use the metric of score typing again.\nI would also like to highlight the skewness and the distribution have multiple peaks. In the data there are definitely multiple groups, as not only were there normal Pokemon, there were also legendary Pokemon, which are intentionally made by the Pokemon company to be stronger due to story reason, but there are also a type of Pokemon I like to call gimmicks (because its basically the same thing under different names) which are also made strong due to the power of friendship. For that reason I would think that to make the analysis better in the future, it would be best to separate the groups from the normal set of Pokemon and conduct an analysis on those separately.\n\n\nTo answer the initial questions that I started, according to the data, there is not outstanding type matchup for Pokemon. In terms of stats, Eternatus-Eternamax seems to be the strongest in both pure stats and with the type score modifier for both overall and defensive, but in terms of pure total attack power, Rayquaza-Mega comes out on top. The lack of an outstanding type matchup for Pokemon makes sense in this data analysis because it would cause gameplay to become unbalanced. Say, for example, your favorite MMORPG game had an overpowered weapon that was capable of destroying everything and anything. All the players would flock to using that weapon and discard all other available weapons in favor for it. The same applies here. The Pokemon franchise prides itself upon its variety of different Pokemon and type-matchup dependent battles. To allow for one type to have a clear advantage would be akin to destroying the mechanics of the game. However, you may find yourself wondering why some Pokemon are so much better than others at all. This is because the Pokemon with higher stats are often legendary or mythical Pokemon, or locked behind some form of story in the game. These Pokemon are the challenge to the player or one of the final bosses, and are thus made intentionally difficult to fight, thus still preserving the reasoning from before.\n\n\n\nEternatus-Eternamax\n\n\n\n\n\nThere are, however, limitations to the comparisons made in this data. Even with set stats, there are many varying factors that all contribute in deciding the victor in a Pokemon battle. It’s near impossible to conclude the winner of a battle just from conclusions driven from hard numerical data, as for example, Pokemon may learn moves of a different type than the Pokemon’s base type, or the level of the Pokemon can boost its stats to that of a level where it can win against a different Pokemon it would normally be at a disadvantage against. Even as we’re talking about predetermined stats, there are abilities or items that Pokemon have that can drastically alter it’s abilities or stats unexpectedly. Professional pokemon players have pulled off huge upstart wins with strategies utilizing these miscellaneous abilities and gimmicks, so it’s not to say this data is the end all be all."
  }
]