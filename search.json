[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "title",
    "section": "",
    "text": "Post With Code\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nanalysis\n\n\n\n\n\n\n\n\n\nAug 2, 2024\n\n\nHarlow Malloc\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nJul 30, 2024\n\n\nTristan O’Malley\n\n\n\n\n\n\n\n\n\n\n\n\nFirst File\n\n\n\n\n\nTesting Quarto\n\n\n\n\n\nJul 17, 2024\n\n\nYour Name\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/post-with-code/index.html",
    "href": "posts/post-with-code/index.html",
    "title": "Post With Code",
    "section": "",
    "text": "This is a post with executable code."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "posts/Session03_NB2_PandasDatasaurus.html",
    "href": "posts/Session03_NB2_PandasDatasaurus.html",
    "title": "First File",
    "section": "",
    "text": "https://pandas.pydata.org/\nPandas data-manipulation capabilities are built on top of NumPy, utilizing its fast array processing, and its graphing capabilities are built on top of Matplotlib.\nImport the library:\nimport pandas as pd\nImport the data:\ndinodata = pd.read_csv('https://raw.githubusercontent.com/benjum/UCLA-24A6-DH140/main/data/DatasaurusDozen.csv')\nLook at some data values:\ndinodata\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.384600\n97.179500\n\n\n1\ndino\n51.538500\n96.025600\n\n\n2\ndino\n46.153800\n94.487200\n\n\n3\ndino\n42.820500\n91.410300\n\n\n4\ndino\n40.769200\n88.333300\n\n\n...\n...\n...\n...\n\n\n1841\nwide_lines\n33.674442\n26.090490\n\n\n1842\nwide_lines\n75.627255\n37.128752\n\n\n1843\nwide_lines\n40.610125\n89.136240\n\n\n1844\nwide_lines\n39.114366\n96.481751\n\n\n1845\nwide_lines\n34.583829\n89.588902\n\n\n\n\n1846 rows × 3 columns\nMaking a scatter plot of the data in the x and y columns is easy:\ndinodata.plot(x = 'x', y = 'y', kind = 'scatter')"
  },
  {
    "objectID": "posts/Session03_NB2_PandasDatasaurus.html#basic-data-structures-in-pandas",
    "href": "posts/Session03_NB2_PandasDatasaurus.html#basic-data-structures-in-pandas",
    "title": "First File",
    "section": "Basic data structures in Pandas",
    "text": "Basic data structures in Pandas\nPython can store values in a variety of data structures: single variables, lists, dictionaries, sets, etc.\nPandas has two key data structures for storing Python variables:\n\nSeries\n\n1D\nLike an array\nItems are labeled by an index\n\nDataframes\n\n2D\nLike a spreadsheet\nItems are labeled by an index (row label) and column name\n\n\ndinodata is a dataframe:\n\ndinodata\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.384600\n97.179500\n\n\n1\ndino\n51.538500\n96.025600\n\n\n2\ndino\n46.153800\n94.487200\n\n\n3\ndino\n42.820500\n91.410300\n\n\n4\ndino\n40.769200\n88.333300\n\n\n...\n...\n...\n...\n\n\n1841\nwide_lines\n33.674442\n26.090490\n\n\n1842\nwide_lines\n75.627255\n37.128752\n\n\n1843\nwide_lines\n40.610125\n89.136240\n\n\n1844\nwide_lines\n39.114366\n96.481751\n\n\n1845\nwide_lines\n34.583829\n89.588902\n\n\n\n\n1846 rows × 3 columns\n\n\n\n\nhead(n): show us the first n rows (5 by default)\ntail(n): show us the last n rows (5 by default)\ninfo() : a range of summary info\n\n\ndinodata.head()\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.3846\n97.1795\n\n\n1\ndino\n51.5385\n96.0256\n\n\n2\ndino\n46.1538\n94.4872\n\n\n3\ndino\n42.8205\n91.4103\n\n\n4\ndino\n40.7692\n88.3333\n\n\n\n\n\n\n\n\ndinodata.tail()\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n1841\nwide_lines\n33.674442\n26.090490\n\n\n1842\nwide_lines\n75.627255\n37.128752\n\n\n1843\nwide_lines\n40.610125\n89.136240\n\n\n1844\nwide_lines\n39.114366\n96.481751\n\n\n1845\nwide_lines\n34.583829\n89.588902\n\n\n\n\n\n\n\n\ndinodata.info()\n\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 1846 entries, 0 to 1845\nData columns (total 3 columns):\n #   Column   Non-Null Count  Dtype  \n---  ------   --------------  -----  \n 0   dataset  1846 non-null   object \n 1   x        1846 non-null   float64\n 2   y        1846 non-null   float64\ndtypes: float64(2), object(1)\nmemory usage: 43.4+ KB\n\n\nThere are several other useful dataframe attributes and methods that will allow you to get summary info: * columns : column names * dtypes : data types of the columns (dataframes can hold different datatypes in different columns) * index : information about the row indices (they don’t have to be numerical) * shape : the size of the dataframe in each dimension * describe() : basic statistics about the data columns\n\ndinodata.columns\n\nIndex(['dataset', 'x', 'y'], dtype='object')\n\n\n\ndinodata.dtypes\n\ndataset     object\nx          float64\ny          float64\ndtype: object\n\n\n\ndinodata.index\n\nRangeIndex(start=0, stop=1846, step=1)\n\n\n\ndinodata.shape\n\n(1846, 3)\n\n\n\ndinodata.describe()\n\n\n\n\n\n\n\n\nx\ny\n\n\n\n\ncount\n1846.000000\n1846.000000\n\n\nmean\n54.265695\n47.835099\n\n\nstd\n16.713001\n26.847766\n\n\nmin\n15.560750\n0.015119\n\n\n25%\n41.073403\n22.561073\n\n\n50%\n52.591269\n47.594450\n\n\n75%\n67.277845\n71.810778\n\n\nmax\n98.288123\n99.694680\n\n\n\n\n\n\n\n\ndinodata.describe(include = 'all')\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\ncount\n1846\n1846.000000\n1846.000000\n\n\nunique\n13\nNaN\nNaN\n\n\ntop\ndino\nNaN\nNaN\n\n\nfreq\n142\nNaN\nNaN\n\n\nmean\nNaN\n54.265695\n47.835099\n\n\nstd\nNaN\n16.713001\n26.847766\n\n\nmin\nNaN\n15.560750\n0.015119\n\n\n25%\nNaN\n41.073403\n22.561073\n\n\n50%\nNaN\n52.591269\n47.594450\n\n\n75%\nNaN\n67.277845\n71.810778\n\n\nmax\nNaN\n98.288123\n99.694680\n\n\n\n\n\n\n\nIf you select one of the columns of dinodata you’ll get a Series in return:\n\ndinodata['dataset']\n\n0             dino\n1             dino\n2             dino\n3             dino\n4             dino\n           ...    \n1841    wide_lines\n1842    wide_lines\n1843    wide_lines\n1844    wide_lines\n1845    wide_lines\nName: dataset, Length: 1846, dtype: object"
  },
  {
    "objectID": "posts/Session03_NB2_PandasDatasaurus.html#selecting-data-from-a-dataframe",
    "href": "posts/Session03_NB2_PandasDatasaurus.html#selecting-data-from-a-dataframe",
    "title": "First File",
    "section": "Selecting data from a dataframe",
    "text": "Selecting data from a dataframe\nIf you have a dataframe df and want to look at a specific column columnname, use df['columnname']\n\ndinodata['x']\n\n0       55.384600\n1       51.538500\n2       46.153800\n3       42.820500\n4       40.769200\n          ...    \n1841    33.674442\n1842    75.627255\n1843    40.610125\n1844    39.114366\n1845    34.583829\nName: x, Length: 1846, dtype: float64\n\n\nDataframe can have both numerical- and label-based indices. There is specific data retrieval syntax that accommodates this.\n\n# This will give an error!\ndinodata[0]\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nFile ~/DH140/.venv/lib/python3.11/site-packages/pandas/core/indexes/base.py:3805, in Index.get_loc(self, key)\n   3804 try:\n-&gt; 3805     return self._engine.get_loc(casted_key)\n   3806 except KeyError as err:\n\nFile index.pyx:167, in pandas._libs.index.IndexEngine.get_loc()\n\nFile index.pyx:196, in pandas._libs.index.IndexEngine.get_loc()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7081, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nFile pandas/_libs/hashtable_class_helper.pxi:7089, in pandas._libs.hashtable.PyObjectHashTable.get_item()\n\nKeyError: 0\n\nThe above exception was the direct cause of the following exception:\n\nKeyError                                  Traceback (most recent call last)\nCell In[22], line 2\n      1 # This will give an error!\n----&gt; 2 dinodata[0]\n\nFile ~/DH140/.venv/lib/python3.11/site-packages/pandas/core/frame.py:4102, in DataFrame.__getitem__(self, key)\n   4100 if self.columns.nlevels &gt; 1:\n   4101     return self._getitem_multilevel(key)\n-&gt; 4102 indexer = self.columns.get_loc(key)\n   4103 if is_integer(indexer):\n   4104     indexer = [indexer]\n\nFile ~/DH140/.venv/lib/python3.11/site-packages/pandas/core/indexes/base.py:3812, in Index.get_loc(self, key)\n   3807     if isinstance(casted_key, slice) or (\n   3808         isinstance(casted_key, abc.Iterable)\n   3809         and any(isinstance(x, slice) for x in casted_key)\n   3810     ):\n   3811         raise InvalidIndexError(key)\n-&gt; 3812     raise KeyError(key) from err\n   3813 except TypeError:\n   3814     # If we have a listlike key, _check_indexing_error will raise\n   3815     #  InvalidIndexError. Otherwise we fall through and re-raise\n   3816     #  the TypeError.\n   3817     self._check_indexing_error(key)\n\nKeyError: 0\n\n\n\n\n# This will not give an error\ndinodata[0:1]\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.3846\n97.1795\n\n\n\n\n\n\n\nIt’s best to stick with loc and iloc for the moment to index dataframes. * loc : label-based indexing (which can look numerical if the row index is a number) * iloc : numerical indexing\n\n# the first row;\n# return value is a Series\n\ndinodata.loc[0]\n\ndataset       dino\nx          55.3846\ny          97.1795\nName: 0, dtype: object\n\n\n\n# the first row;\n# return value is a Dataframe (note the index is [0])\n\ndinodata.loc[[0]]\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.3846\n97.1795\n\n\n\n\n\n\n\n\n# the first two rows;\n# return value is a Dataframe (the index is a list [0,1])\n\ndinodata.loc[[0,1]]\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.3846\n97.1795\n\n\n1\ndino\n51.5385\n96.0256\n\n\n\n\n\n\n\n\n# indexing both the row and column\n\ndinodata.loc[0,'x']\n\n55.3846\n\n\n\n# indexing both the row and column\n# and returning a dataframe\n\ndinodata.loc[[0],['x']]\n\n\n\n\n\n\n\n\nx\n\n\n\n\n0\n55.3846\n\n\n\n\n\n\n\n\n# you can use lists for the indices\n\ndinodata.loc[[0],['x','y']]\n\n\n\n\n\n\n\n\nx\ny\n\n\n\n\n0\n55.3846\n97.1795\n\n\n\n\n\n\n\n\ndinodata.loc[[10],['x','y']]\n\n\n\n\n\n\n\n\nx\ny\n\n\n\n\n10\n23.0769\n66.4103\n\n\n\n\n\n\n\niloc is useful when you instead want to index numerically.\n\ndinodata.iloc[0]\n\ndataset       dino\nx          55.3846\ny          97.1795\nName: 0, dtype: object\n\n\nBefore you execute the below, try to predict whether it will return a Series or a Dataframe.\n\ndinodata.iloc[1]\n\ndataset       dino\nx          51.5385\ny          96.0256\nName: 1, dtype: object\n\n\n\ndinodata.iloc[[1]]\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n1\ndino\n51.5385\n96.0256\n\n\n\n\n\n\n\n\ndinodata.iloc[0:1]\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.3846\n97.1795\n\n\n\n\n\n\n\n\ndinodata.iloc[0:4]\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.3846\n97.1795\n\n\n1\ndino\n51.5385\n96.0256\n\n\n2\ndino\n46.1538\n94.4872\n\n\n3\ndino\n42.8205\n91.4103\n\n\n\n\n\n\n\n\n# this will give an error! you can't use a label-based index like 'x' with iloc\n\ndinodata.iloc[0:4,'x']\n\n\n---------------------------------------------------------------------------\nValueError                                Traceback (most recent call last)\nFile ~/DH140/.venv/lib/python3.11/site-packages/pandas/core/indexing.py:966, in _LocationIndexer._validate_tuple_indexer(self, key)\n    965 try:\n--&gt; 966     self._validate_key(k, i)\n    967 except ValueError as err:\n\nFile ~/DH140/.venv/lib/python3.11/site-packages/pandas/core/indexing.py:1614, in _iLocIndexer._validate_key(self, key, axis)\n   1613 else:\n-&gt; 1614     raise ValueError(f\"Can only index by location with a [{self._valid_types}]\")\n\nValueError: Can only index by location with a [integer, integer slice (START point is INCLUDED, END point is EXCLUDED), listlike of integers, boolean array]\n\nThe above exception was the direct cause of the following exception:\n\nValueError                                Traceback (most recent call last)\nCell In[36], line 3\n      1 # this will give an error! you can't use a label-based index like 'x' with iloc\n----&gt; 3 dinodata.iloc[0:4,'x']\n\nFile ~/DH140/.venv/lib/python3.11/site-packages/pandas/core/indexing.py:1184, in _LocationIndexer.__getitem__(self, key)\n   1182     if self._is_scalar_access(key):\n   1183         return self.obj._get_value(*key, takeable=self._takeable)\n-&gt; 1184     return self._getitem_tuple(key)\n   1185 else:\n   1186     # we by definition only have the 0th axis\n   1187     axis = self.axis or 0\n\nFile ~/DH140/.venv/lib/python3.11/site-packages/pandas/core/indexing.py:1690, in _iLocIndexer._getitem_tuple(self, tup)\n   1689 def _getitem_tuple(self, tup: tuple):\n-&gt; 1690     tup = self._validate_tuple_indexer(tup)\n   1691     with suppress(IndexingError):\n   1692         return self._getitem_lowerdim(tup)\n\nFile ~/DH140/.venv/lib/python3.11/site-packages/pandas/core/indexing.py:968, in _LocationIndexer._validate_tuple_indexer(self, key)\n    966         self._validate_key(k, i)\n    967     except ValueError as err:\n--&gt; 968         raise ValueError(\n    969             \"Location based indexing can only have \"\n    970             f\"[{self._valid_types}] types\"\n    971         ) from err\n    972 return key\n\nValueError: Location based indexing can only have [integer, integer slice (START point is INCLUDED, END point is EXCLUDED), listlike of integers, boolean array] types\n\n\n\n\n# instead of referncing the column with 'x'\n# iloc indexes it numerically\n\ndinodata.iloc[0:4, 1]\n\n0    55.3846\n1    51.5385\n2    46.1538\n3    42.8205\nName: x, dtype: float64\n\n\n\ndinodata.iloc[[0,1,2,3],[1]]\n\n\n\n\n\n\n\n\nx\n\n\n\n\n0\n55.3846\n\n\n1\n51.5385\n\n\n2\n46.1538\n\n\n3\n42.8205\n\n\n\n\n\n\n\n\ndinodata.iloc[0,0]\n\n'dino'\n\n\n\ndinodata.loc[0,'dataset']\n\n'dino'"
  },
  {
    "objectID": "posts/Session03_NB2_PandasDatasaurus.html#whats-the-data-for-dataset-dino-boolean-indexing",
    "href": "posts/Session03_NB2_PandasDatasaurus.html#whats-the-data-for-dataset-dino-boolean-indexing",
    "title": "First File",
    "section": "What’s the data for ‘dataset’ == ‘dino’? Boolean indexing",
    "text": "What’s the data for ‘dataset’ == ‘dino’? Boolean indexing\nIt is useful to be able to get elements where certain conditions are true.\nLike here, we may want to get only those rows that are part of the ‘dino’ dataset.\nThis can be accomplished with boolean indexing, where the index is a True/False condition, and there is one such value for every row.\nThe following sets up the boolean series of True/False values for every row.\n\ndinodata['dataset'] == 'dino'\n\n0        True\n1        True\n2        True\n3        True\n4        True\n        ...  \n1841    False\n1842    False\n1843    False\n1844    False\n1845    False\nName: dataset, Length: 1846, dtype: bool\n\n\nWe can use that as the index to dinodata, i.e., for any dataframe df we can use df[condition] to get only those rows where condition is True\n\ndinodata[dinodata['dataset'] == 'dino']\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.3846\n97.1795\n\n\n1\ndino\n51.5385\n96.0256\n\n\n2\ndino\n46.1538\n94.4872\n\n\n3\ndino\n42.8205\n91.4103\n\n\n4\ndino\n40.7692\n88.3333\n\n\n...\n...\n...\n...\n\n\n137\ndino\n39.4872\n25.3846\n\n\n138\ndino\n91.2821\n41.5385\n\n\n139\ndino\n50.0000\n95.7692\n\n\n140\ndino\n47.9487\n95.0000\n\n\n141\ndino\n44.1026\n92.6923\n\n\n\n\n142 rows × 3 columns\n\n\n\nBoolean indexing also works as the index when using loc\n\ndinodata.loc[dinodata['dataset'] == 'dino']\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.3846\n97.1795\n\n\n1\ndino\n51.5385\n96.0256\n\n\n2\ndino\n46.1538\n94.4872\n\n\n3\ndino\n42.8205\n91.4103\n\n\n4\ndino\n40.7692\n88.3333\n\n\n...\n...\n...\n...\n\n\n137\ndino\n39.4872\n25.3846\n\n\n138\ndino\n91.2821\n41.5385\n\n\n139\ndino\n50.0000\n95.7692\n\n\n140\ndino\n47.9487\n95.0000\n\n\n141\ndino\n44.1026\n92.6923\n\n\n\n\n142 rows × 3 columns\n\n\n\n\ndinodata.loc[dinodata['dataset'] == 'circle']\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n1136\ncircle\n55.993030\n79.277264\n\n\n1137\ncircle\n50.032254\n79.013071\n\n\n1138\ncircle\n51.288459\n82.435940\n\n\n1139\ncircle\n51.170537\n79.165294\n\n\n1140\ncircle\n44.377915\n78.164628\n\n\n...\n...\n...\n...\n\n\n1273\ncircle\n39.921363\n19.701850\n\n\n1274\ncircle\n84.794278\n55.568650\n\n\n1275\ncircle\n55.662959\n83.356480\n\n\n1276\ncircle\n50.492248\n78.997532\n\n\n1277\ncircle\n51.467101\n79.201845\n\n\n\n\n142 rows × 3 columns\n\n\n\nNote above what happens to the indices. You should keep in mind this behavior if you want to index the returned result.\n\ndinodata.loc[dinodata['dataset'] == 'dino','x']\n\n0      55.3846\n1      51.5385\n2      46.1538\n3      42.8205\n4      40.7692\n        ...   \n137    39.4872\n138    91.2821\n139    50.0000\n140    47.9487\n141    44.1026\nName: x, Length: 142, dtype: float64\n\n\n\ndinodata['dataset'].str.startswith('d')\n\n0        True\n1        True\n2        True\n3        True\n4        True\n        ...  \n1841    False\n1842    False\n1843    False\n1844    False\n1845    False\nName: dataset, Length: 1846, dtype: bool\n\n\n\ndinodata.loc[dinodata['dataset'].str.startswith('d')]\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.384600\n97.179500\n\n\n1\ndino\n51.538500\n96.025600\n\n\n2\ndino\n46.153800\n94.487200\n\n\n3\ndino\n42.820500\n91.410300\n\n\n4\ndino\n40.769200\n88.333300\n\n\n...\n...\n...\n...\n\n\n1131\ndots\n50.533635\n17.019581\n\n\n1132\ndots\n77.500907\n50.166986\n\n\n1133\ndots\n50.691124\n87.513960\n\n\n1134\ndots\n49.990395\n83.997357\n\n\n1135\ndots\n50.127182\n82.990750\n\n\n\n\n284 rows × 3 columns\n\n\n\n\ndinodata.loc[dinodata['dataset'].str.contains('in')]\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.384600\n97.179500\n\n\n1\ndino\n51.538500\n96.025600\n\n\n2\ndino\n46.153800\n94.487200\n\n\n3\ndino\n42.820500\n91.410300\n\n\n4\ndino\n40.769200\n88.333300\n\n\n...\n...\n...\n...\n\n\n1841\nwide_lines\n33.674442\n26.090490\n\n\n1842\nwide_lines\n75.627255\n37.128752\n\n\n1843\nwide_lines\n40.610125\n89.136240\n\n\n1844\nwide_lines\n39.114366\n96.481751\n\n\n1845\nwide_lines\n34.583829\n89.588902\n\n\n\n\n710 rows × 3 columns\n\n\n\nDataframes have many very useful methods.\n… which we will ignore for the moment until next week when we get to exploratory data analysis.\nFor now: plotting!"
  },
  {
    "objectID": "posts/Session03_NB2_PandasDatasaurus.html#plotting",
    "href": "posts/Session03_NB2_PandasDatasaurus.html#plotting",
    "title": "First File",
    "section": "Plotting",
    "text": "Plotting\nLet’s make a scatter plot with only the dino dataset\n\n# How do we get that subset of data?\n\na = dinodata[dinodata['dataset'] == 'dino']\n\nMake a plot:\n\na.plot(x='x', y='y')\n\n\n\n\n\n\n\n\nWhat’s with the zig-zags?\nBy default, pandas will make a line plot connecting the points, and since the points are plotted out of numerical order, the connecting lines zigs back and forth in the x and y direction.\nWe actually want to plot this as a scatter plot instead of a line plot.\n\na.plot(x='x', y='y', kind='scatter')\n\n\n\n\n\n\n\n\nThe kind parameter makes it very easy to make a variety of different elementary plots:\n\nline : line plot\nbar : vertical bar plot\nbarh : horizontal bar plot\nhist : histogram\nbox : boxplot\nkde : kernel density estimation plot\ndensity : same as kde\narea : area plot\npie : pie plot\nscatter : scatter plot\nhexbin : hexbin plot\n\n\na.plot(x='x', y='y', kind='bar')\n\n\n\n\n\n\n\n\nThis, of course, doesn’t mean that you don’t have to think about what you want to plot before-hand.\nTo make things easier, let’s look at a subset of data:\n\nb = a[0:15]\n\n\nb\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n0\ndino\n55.3846\n97.1795\n\n\n1\ndino\n51.5385\n96.0256\n\n\n2\ndino\n46.1538\n94.4872\n\n\n3\ndino\n42.8205\n91.4103\n\n\n4\ndino\n40.7692\n88.3333\n\n\n5\ndino\n38.7179\n84.8718\n\n\n6\ndino\n35.6410\n79.8718\n\n\n7\ndino\n33.0769\n77.5641\n\n\n8\ndino\n28.9744\n74.4872\n\n\n9\ndino\n26.1538\n71.4103\n\n\n10\ndino\n23.0769\n66.4103\n\n\n11\ndino\n22.3077\n61.7949\n\n\n12\ndino\n22.3077\n57.1795\n\n\n13\ndino\n23.3333\n52.9487\n\n\n14\ndino\n25.8974\n51.0256\n\n\n\n\n\n\n\n\nb.plot(x='x', y='y', kind='bar')\n\n\n\n\n\n\n\n\nNote that pandas does not necessarily try to order the x-axis here for us.\n\nb.sort_values(by='x')\n\n\n\n\n\n\n\n\ndataset\nx\ny\n\n\n\n\n12\ndino\n22.3077\n57.1795\n\n\n11\ndino\n22.3077\n61.7949\n\n\n10\ndino\n23.0769\n66.4103\n\n\n13\ndino\n23.3333\n52.9487\n\n\n14\ndino\n25.8974\n51.0256\n\n\n9\ndino\n26.1538\n71.4103\n\n\n8\ndino\n28.9744\n74.4872\n\n\n7\ndino\n33.0769\n77.5641\n\n\n6\ndino\n35.6410\n79.8718\n\n\n5\ndino\n38.7179\n84.8718\n\n\n4\ndino\n40.7692\n88.3333\n\n\n3\ndino\n42.8205\n91.4103\n\n\n2\ndino\n46.1538\n94.4872\n\n\n1\ndino\n51.5385\n96.0256\n\n\n0\ndino\n55.3846\n97.1795\n\n\n\n\n\n\n\n\nb.sort_values(by='x').plot()\n\n\n\n\n\n\n\n\n\nb.sort_values(by='x').plot(x='x', y='y', kind='bar')\n\n\n\n\n\n\n\n\n\nb.sort_values(by='x').plot(x='x', y='y', kind='barh')\n\n\n\n\n\n\n\n\n\na.plot(x='x',\n       y='y',\n       kind='scatter')\n\n\n\n\n\n\n\n\n\na.plot(x='x',\n       y='y',\n       kind='scatter',\n       figsize=(5,5))\n\n\n\n\n\n\n\n\n\na.plot(x='x',\n       y='y',\n       kind='scatter',\n       figsize=(5,5),\n       xlabel='hdata',\n       ylabel='vdata')\n\n\n\n\n\n\n\n\n\na.plot(x='x',\n       y='y',\n       kind='scatter',\n       figsize=(5,5),\n       xlabel='hdata',\n       ylabel='vdata',\n       color='black')\n\n\n\n\n\n\n\n\n\ndinodata[dinodata['dataset']=='dino'].plot(x='x',\n       y='y',\n       kind='scatter',\n       figsize=(5,5),\n       xlabel='hdata',\n       ylabel='vdata',\n       color='black')\n\n\n\n\n\n\n\n\nWhat datasets can we look at?\n\ndinodata['dataset'].unique()\n\narray(['dino', 'away', 'h_lines', 'v_lines', 'x_shape', 'star',\n       'high_lines', 'dots', 'circle', 'bullseye', 'slant_up',\n       'slant_down', 'wide_lines'], dtype=object)\n\n\n\ndatasets = dinodata['dataset'].unique()\n\n\nd2plot = 3\n\nprint(datasets[d2plot])\n\ndinodata[dinodata['dataset'] == datasets[d2plot]].plot(x='x',\n       y='y',\n       kind='scatter',\n       figsize=(5,5),\n       xlabel='hdata',\n       ylabel='vdata',\n       color='black')\n\nv_lines"
  },
  {
    "objectID": "posts/Session03_NB2_PandasDatasaurus.html#brief-hint-of-fun-stuff-to-come",
    "href": "posts/Session03_NB2_PandasDatasaurus.html#brief-hint-of-fun-stuff-to-come",
    "title": "First File",
    "section": "Brief hint of fun stuff to come",
    "text": "Brief hint of fun stuff to come\n\nimport matplotlib.pyplot as plt\nimport ipywidgets\n\n\ndef dinoplot(dataset):\n    fig,ax = plt.subplots(2,2,figsize=(12,12))\n    dinodata[dinodata['dataset']==dataset].plot(x='y',\n           y='x',\n           kind='hist',\n           figsize=(5,5),\n           xlabel='hdata',\n           ylabel='vdata',\n           color='black', ax=ax[0,0])\n    dinodata[dinodata['dataset']==dataset].plot(x='x',\n           y='y',\n           kind='scatter',\n           figsize=(5,5),\n           xlabel='hdata',\n           ylabel='vdata',\n           color='black', ax=ax[1,0])\n    ax[0,1].text(0.25,0.8,'x_mean = {:.2f}'.format(dinodata.loc[dinodata['dataset']==dataset,'x'].mean()))\n    ax[0,1].text(0.25,0.6,'y_mean = {:.2f}'.format(dinodata.loc[dinodata['dataset']==dataset,'y'].mean()))\n    ax[0,1].text(0.25,0.4,'x_stddev = {:.2f}'.format(dinodata.loc[dinodata['dataset']==dataset,'x'].std()))\n    ax[0,1].text(0.25,0.2,'y_stddev = {:.2f}'.format(dinodata.loc[dinodata['dataset']==dataset,'y'].std()))\n    dinodata[dinodata['dataset']==dataset].plot(x='x',\n           y='y',\n           kind='hist',\n           figsize=(5,5),\n           xlabel='hdata',\n           ylabel='vdata',\n           color='black', ax=ax[1,1])\n    \nipywidgets.interact(dinoplot,dataset=datasets)\n\n\n\n\n&lt;function __main__.dinoplot(dataset)&gt;"
  }
]